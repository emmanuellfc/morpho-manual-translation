msgid ""
msgstr ""
"Project-Id-Version: Morpho Manual\n"
"POT-Creation-Date: 2024-05-15T17:45:18-04:00\n"
"PO-Revision-Date: 2024-05-15 17:48-0400\n"
"Last-Translator: Emmanuel Flores <eq.emmanuel.137@gmail.com>\n"
"Language-Team: Spanish <es@tp.org.es>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 3.4.4\n"

#: src/SUMMARY.md:1
msgid "The Morpho Manual"
msgstr "El Manual Morpho"

#: src/SUMMARY.md:3
msgid "Foreword"
msgstr "Introducción"

#: src/SUMMARY.md:4 src/overview.md:1
msgid "Overview"
msgstr "Descripción general"

#: src/SUMMARY.md:5
msgid "Installing Morpho"
msgstr ""

#: src/SUMMARY.md:6 src/installing/homebrew.md:1
msgid "Install with homebrew"
msgstr ""

#: src/SUMMARY.md:7
msgid "Install with source"
msgstr ""

#: src/SUMMARY.md:8 src/installing/wsl.md:1
msgid "Windows via Windows Subsystem for Linux (WSL)"
msgstr ""

#: src/SUMMARY.md:9 src/installing/updating.md:1
msgid "Updating _morpho_"
msgstr ""

#: src/SUMMARY.md:10 src/installing/uninstalling.md:1
msgid "Uninstalling _morpho_"
msgstr ""

#: src/SUMMARY.md:11
msgid "Using Morpho"
msgstr ""

#: src/SUMMARY.md:12 src/tutorial.md:1
msgid "Tutorial"
msgstr ""

#: src/SUMMARY.md:13
msgid "Importing Modules"
msgstr ""

#: src/SUMMARY.md:14
msgid "Morpho Language"
msgstr ""

#: src/SUMMARY.md:15 src/tutorial/creating_the_initial_mesh.md:1
msgid "Creating the initial mesh"
msgstr ""

#: src/SUMMARY.md:16 src/tutorial/selections.md:1
#: src/visualization/plot_module.md:98
msgid "Selections"
msgstr ""

#: src/SUMMARY.md:17 src/tutorial/fields.md:1
#: src/visualization/plot_module.md:137
msgid "Fields"
msgstr ""

#: src/SUMMARY.md:18 src/tutorial/defining_the_problem.md:1
msgid "Defining the problem"
msgstr ""

#: src/SUMMARY.md:19 src/tutorial/performing_the_optimization.md:1
msgid "Performing the optimization"
msgstr ""

#: src/SUMMARY.md:20
msgid "Visualizing the results"
msgstr ""

#: src/SUMMARY.md:21 src/tutorial/refinement.md:1
msgid "Refinement"
msgstr ""

#: src/SUMMARY.md:22 src/tutorial/next_steps.md:1
msgid "Next steps"
msgstr ""

#: src/SUMMARY.md:23
msgid "Working with meshes"
msgstr ""

#: src/SUMMARY.md:24 src/working_with_meshes/meshgen_module.md:1
msgid "The meshgen module"
msgstr ""

#: src/SUMMARY.md:25 src/working_with_meshes/meshtools_module.md:1
msgid "The meshtools module"
msgstr ""

#: src/SUMMARY.md:26 src/working_with_meshes/vtk_module.md:1
msgid "The vtk module"
msgstr ""

#: src/SUMMARY.md:27 src/working_with_meshes/merging_meshes.md:1
msgid "Merging meshes"
msgstr ""

#: src/SUMMARY.md:28 src/working_with_meshes/slicing_meshes.md:1
msgid "Slicing meshes"
msgstr ""

#: src/SUMMARY.md:29 src/visualization.md:1 src/examples/qtensor.md:154
msgid "Visualization"
msgstr ""

#: src/SUMMARY.md:30 src/visualization/plot_module.md:1
msgid "The plot module"
msgstr ""

#: src/SUMMARY.md:31 src/visualization/graphics_module.md:1
msgid "The graphics module"
msgstr ""

#: src/SUMMARY.md:32 src/visualization/povray_module.md:1
msgid "The povray module"
msgstr ""

#: src/SUMMARY.md:33 src/examples.md:1
msgid "Examples"
msgstr ""

#: src/SUMMARY.md:34 src/examples/catenoid.md:1
msgid "Catenoid"
msgstr ""

#: src/SUMMARY.md:35 src/examples/cholesteric.md:1
msgid "Cholesteric"
msgstr ""

#: src/SUMMARY.md:36 src/examples/cube.md:1
msgid "Cube"
msgstr ""

#: src/SUMMARY.md:37 src/SUMMARY.md:80 src/examples/delaunay.md:1
#: src/reference/nested/delaunay.md:4
msgid "Delaunay"
msgstr ""

#: src/SUMMARY.md:38 src/examples/dla.md:1
msgid "DLA"
msgstr ""

#: src/SUMMARY.md:39 src/examples/electrostatics.md:1
msgid "Electrostatics"
msgstr ""

#: src/SUMMARY.md:40 src/SUMMARY.md:82 src/examples/implicitmesh.md:1
msgid "Implicitmesh"
msgstr ""

#: src/SUMMARY.md:41 src/examples/meshgen.md:1
#: src/reference/nested/meshgen.md:4
msgid "Meshgen"
msgstr ""

#: src/SUMMARY.md:42 src/examples/meshslice.md:1
#: src/reference/nested/meshslice.md:4
msgid "Meshslice"
msgstr ""

#: src/SUMMARY.md:43 src/SUMMARY.md:88 src/examples/plot.md:1
#: src/reference/nested/plot.md:4
msgid "Plot"
msgstr ""

#: src/SUMMARY.md:44 src/examples/povray.md:1
msgid "Povray"
msgstr ""

#: src/SUMMARY.md:45
msgid "QTensor"
msgstr ""

#: src/SUMMARY.md:46 src/examples/thomson.md:1
msgid "Thomson"
msgstr ""

#: src/SUMMARY.md:47 src/examples/wrap.md:1
msgid "Wrap"
msgstr ""

#: src/SUMMARY.md:48 src/reference.md:1
msgid "Reference"
msgstr ""

#: src/SUMMARY.md:49 src/reference/language.md:1
msgid "Language"
msgstr ""

#: src/SUMMARY.md:50 src/reference/nested/syntax.md:6
msgid "Syntax"
msgstr ""

#: src/SUMMARY.md:51 src/reference/nested/values.md:4
msgid "Values"
msgstr ""

#: src/SUMMARY.md:52 src/reference/nested/variables.md:6
msgid "Variables"
msgstr ""

#: src/SUMMARY.md:53 src/reference/nested/controlflow.md:6
msgid "Control Flow"
msgstr ""

#: src/SUMMARY.md:54 src/reference/nested/functions.md:6
msgid "Functions"
msgstr ""

#: src/SUMMARY.md:55 src/reference/nested/classes.md:6
msgid "Classes"
msgstr ""

#: src/SUMMARY.md:56 src/SUMMARY.md:77 src/reference/nested/modules.md:6
#: src/reference/modules.md:1
msgid "Modules"
msgstr ""

#: src/SUMMARY.md:57 src/reference/nested/help.md:4
msgid "Help"
msgstr ""

#: src/SUMMARY.md:58 src/reference/nested/errors.md:4
msgid "Errors"
msgstr ""

#: src/SUMMARY.md:59
msgid "Built-in Functions"
msgstr ""

#: src/SUMMARY.md:60 src/reference/data_types.md:1
msgid "Data Types"
msgstr ""

#: src/SUMMARY.md:61 src/reference/nested/array.md:4
msgid "Array"
msgstr ""

#: src/SUMMARY.md:62 src/reference/nested/complex.md:4
msgid "Complex"
msgstr ""

#: src/SUMMARY.md:63 src/reference/nested/list.md:4
msgid "List"
msgstr ""

#: src/SUMMARY.md:64 src/reference/nested/matrix.md:4
msgid "Matrix"
msgstr ""

#: src/SUMMARY.md:65 src/reference/nested/range.md:4
msgid "Range"
msgstr ""

#: src/SUMMARY.md:66 src/reference/nested/sparse.md:4
msgid "Sparse"
msgstr ""

#: src/SUMMARY.md:67 src/reference/nested/string.md:4
msgid "String"
msgstr ""

#: src/SUMMARY.md:68 src/reference/nested/tuple.md:4
msgid "Tuple"
msgstr ""

#: src/SUMMARY.md:69 src/reference/computational_geometry.md:1
msgid "Computational Geometry"
msgstr ""

#: src/SUMMARY.md:70 src/reference/nested/field.md:4
msgid "Field"
msgstr ""

#: src/SUMMARY.md:71 src/reference/nested/functionals.md:4
msgid "Functionals"
msgstr ""

#: src/SUMMARY.md:72 src/reference/nested/field.md:42
#: src/reference/nested/mesh.md:4
msgid "Mesh"
msgstr ""

#: src/SUMMARY.md:73 src/reference/nested/selection.md:4
msgid "Selection"
msgstr ""

#: src/SUMMARY.md:74 src/reference/io.md:1
msgid "I/O"
msgstr ""

#: src/SUMMARY.md:75 src/reference/nested/file.md:4
msgid "File"
msgstr ""

#: src/SUMMARY.md:76 src/reference/nested/json.md:6
msgid "JSON"
msgstr ""

#: src/SUMMARY.md:78 src/reference/nested/color.md:4
msgid "Color"
msgstr ""

#: src/SUMMARY.md:79 src/reference/nested/constants.md:4
msgid "Constants"
msgstr ""

#: src/SUMMARY.md:81 src/reference/nested/graphics.md:4
msgid "Graphics"
msgstr ""

#: src/SUMMARY.md:83 src/reference/nested/kdtree.md:4
msgid "KDTree"
msgstr ""

#: src/SUMMARY.md:84
msgid "MeshGen"
msgstr ""

#: src/SUMMARY.md:85
msgid "MeshSlice"
msgstr ""

#: src/SUMMARY.md:86 src/reference/nested/meshtools.md:4
msgid "Meshtools"
msgstr ""

#: src/SUMMARY.md:87 src/reference/nested/optimize.md:4
msgid "Optimize"
msgstr ""

#: src/SUMMARY.md:89 src/reference/nested/povray.md:4
msgid "POVRay"
msgstr ""

#: src/SUMMARY.md:90 src/reference/nested/vtk.md:4
msgid "VTK"
msgstr ""

#: src/SUMMARY.md:92 src/mdbook_notes.md:1
msgid "About this online version"
msgstr ""

#: src/foreword.md:1
msgid "![image](Figures/morphologo.pdf)"
msgstr ""

#: src/foreword.md:2
msgid "Version 0.6.0"
msgstr ""

#: src/foreword.md:5
msgid "_In nova fert animus mutatas dicere formas_"
msgstr ""

#: src/foreword.md:7
msgid "_corpora; di, coeptis (nam vos mutastis et illas)_"
msgstr ""

#: src/foreword.md:9
msgid "_adspirate meis primaque ab origine mundi_"
msgstr ""

#: src/foreword.md:11
msgid "_ad mea perpetuum deducite tempora carmen!_"
msgstr ""

#: src/foreword.md:13
msgid "\\--- Ovid, _Metamorphoses_"
msgstr ""

#: src/foreword.md:15
msgid "Acknowledgements"
msgstr ""

#: src/foreword.md:17
msgid ""
"The principal architect of _morpho_, T J Atherton, wishes to thank the many "
"people who have used various versions of the program or otherwise "
"contributed to the project:"
msgstr ""

#: src/foreword.md:23
msgid "Andrew DeBenedictis"
msgstr ""

#: src/foreword.md:23
msgid "Danny Goldstein"
msgstr ""

#: src/foreword.md:24
msgid "Ian Hunter"
msgstr ""

#: src/foreword.md:24
msgid "Chaitanya Joshi"
msgstr ""

#: src/foreword.md:25
msgid "Cole Wennerholm"
msgstr ""

#: src/foreword.md:25
msgid "Eoghan Downey"
msgstr ""

#: src/foreword.md:26
msgid "Allison Culbert"
msgstr ""

#: src/foreword.md:26
msgid "Abigail Wilson"
msgstr ""

#: src/foreword.md:27
msgid "Zhaoyu Xie"
msgstr ""

#: src/foreword.md:27
msgid "Matthew Peterson"
msgstr ""

#: src/foreword.md:28
msgid "Chris Burke"
msgstr ""

#: src/foreword.md:28
msgid "Badel Mbanga"
msgstr ""

#: src/foreword.md:29
msgid "Anca Andrei"
msgstr ""

#: src/foreword.md:29
msgid "Mathew Giso"
msgstr ""

#: src/foreword.md:30
msgid "Sam Hocking"
msgstr ""

#: src/foreword.md:30
msgid "Emmett Hamilton"
msgstr ""

#: src/foreword.md:31
msgid "Hudson Ramirez"
msgstr ""

#: src/foreword.md:31
msgid "Paco Navarro"
msgstr ""

#: src/foreword.md:32
msgid "Emmanuel Flores"
msgstr ""

#: src/foreword.md:34
msgid ""
"_This material is based upon work supported by the National Science "
"Foundation under grants DMR-1654283 and OAC-2003820._"
msgstr ""

#: src/overview.md:3
msgid ""
"_Morpho_ aims to solve the following class of problems. Consider a "
"functional, $$F=\\int\\_{C}f(q,\\nabla q,\\nabla^{2}q,...)d^{n}x+"
"\\int\\_{\\partial C}g(q,\\nabla q,\\nabla^{2}q,...)d^{n-1}x,$$ where \\"
"\\(q\\\\) represents a set of fields defined on a manifold \\\\(C\\\\) that "
"could include scalar, vector, tensor or other quantities and their "
"derivatives \\\\(\\nabla^{n}q\\\\). The functional includes terms in the "
"bulk and on the boundary \\\\(\\partial C\\\\) and might also include "
"geometric properties of the manifold such as local curvatures. This "
"functional is to be minimized from an initial guess \\\\( \\\\{ C\\_{0},"
"q\\_{0} \\\\}\\\\) with respect to the fields \\\\(q\\\\) and the shape of "
"the manifold \\\\(C\\\\). Global and local constraints may be imposed both "
"on \\\\(C\\\\) and \\\\(q\\\\)."
msgstr ""

#: src/overview.md:15
msgid ""
"_Morpho_ is an object-oriented environment: all components of the problem, "
"including the computational domain, fields, functionals etc. are all "
"represented as objects that interact with one another. Much of the effort in "
"writing a _morpho_ program involves creating and manipulating these objects. "
"The environment is flexible, modular, and users can easily create new kinds "
"of object, or entirely change how _morpho_ works."
msgstr ""

#: src/overview.md:23
msgid ""
"This manual aims to help users to learn to use _morpho_. It provides "
"installation instructions in [Chapter 2](installing_morpho.md), information "
"about how to run the program in [Chapter 3](using_morpho.md). A detailed "
"tutorial is provided in [Chapter 4](tutorial.md), showing how to set up and "
"solve an example problem. [Chapter 5](working_with_meshes.md) provides "
"information about working with meshes and [Chapter 6](visualization.md) "
"describes how to visualize the results of your calculation with _morpho_. "
"The examples provided with morpho are described in [Chapter 7](examples.md). "
"The remaining chapters, comprising the second part of the manual, provide a "
"reference guide for all areas of _morpho_ functionality."
msgstr ""

#: src/installing_morpho.md:1
msgid "Installing _Morpho_"
msgstr ""

#: src/installing_morpho.md:3
msgid ""
"_Morpho_ is hosted on a publicly available github repository <https://github."
"com/Morpho-lang/morpho>. _Morpho_ also requires two subsidiary programs, a "
"terminal app hosted in <https://github.com/Morpho-lang/morpho-cli>, and a "
"viewer application <https://github.com/Morpho-lang/morpho-morphoview>. "
"_Morpho_ is extendable, and packages providing additional functionality are "
"hosted in git repositories."
msgstr ""

#: src/installing_morpho.md:11
msgid ""
"For this release, _morpho_ can be installed on all supported platforms using "
"the homebrew package manager. Alternatively, the program can be installed "
"from source as described below. We are continuously working on improving "
"_morpho_ installation, and hope to provide additional mechanisms for "
"installation in upcoming releases."
msgstr ""

#: src/installing/homebrew.md:3
msgid ""
"The simplest way to install _morpho_ is through the [homebrew package "
"manager](https://brew.sh). To do so:"
msgstr ""

#: src/installing/homebrew.md:6
msgid ""
"If not already installed, install homebrew on your machine as described on "
"the [homebrew website](https://brew.sh)."
msgstr ""

#: src/installing/homebrew.md:9
msgid "Open a terminal and type:"
msgstr ""

#: src/installing/homebrew.md:15
msgid ""
"If you need to uninstall morpho, simply open a terminal and type `brew "
"uninstall morpho`. It's very important to uninstall the homebrew morpho in "
"this way _before_ attempting to install from source as below."
msgstr ""

#: src/installing/source.md:1
msgid "Install from source"
msgstr ""

#: src/installing/source.md:3
msgid ""
"The second way to install morpho is by compiling the source code directly. "
"Morpho now leverages the [CMake](https://cmake.org) build system, which "
"enables platform independent builds."
msgstr ""

#: src/installing/source.md:7
msgid "Where a _morpho_ source installation puts things"
msgstr ""

#: src/installing/source.md:9
msgid ""
"A _morpho_ installation includes help files, modules, and other resources. "
"By default, these are installed in the **/usr/local/** file structure as "
"follows:"
msgstr ""

#: src/installing/source.md:13
msgid ""
"**/usr/local/bin** : The morpho and morphoview executables are placed here."
msgstr ""

#: src/installing/source.md:15
msgid "**/usr/local/share/morpho** : Help files and modules are stored here."
msgstr ""

#: src/installing/source.md:17
msgid ""
"**/usr/local/include/morpho** : Morpho header files for building extensions."
msgstr ""

#: src/installing/source.md:19
msgid "**/usr/local/lib/morpho** : Morpho extensions."
msgstr ""

#: src/installing/source.md:21
msgid "Collect Dependencies"
msgstr ""

#: src/installing/source.md:23
msgid "_Morpho_ requires a few libraries to provide certain functionality:"
msgstr ""

#: src/installing/source.md:25
msgid "**blas/lapack** : are used for dense linear algebra."
msgstr ""

#: src/installing/source.md:27
msgid "**suitesparse** : is used for sparse linear algebra."
msgstr ""

#: src/installing/source.md:29
msgid ""
"See <https://people.engr.tamu.edu/davis/suitesparse.html> and publications "
"for details"
msgstr ""

#: src/installing/source.md:31
msgid ""
"**povray** : is a ray-tracer that is used for publication-quality graphics "
"(only required by the `povray` module)."
msgstr ""

#: src/installing/source.md:34
msgid "The terminal application uses"
msgstr ""

#: src/installing/source.md:36
msgid "**libgrapheme** _or_,"
msgstr ""

#: src/installing/source.md:38
msgid "**libunistring**: for unicode grapheme support."
msgstr ""

#: src/installing/source.md:40
msgid "_Morphoview_ additionally requires"
msgstr ""

#: src/installing/source.md:42
msgid "**glfw** : to provide gui functionality."
msgstr ""

#: src/installing/source.md:44
msgid "**freetype** : provides text display."
msgstr ""

#: src/installing/source.md:46
msgid ""
"Each of these dependencies can be installed using any appropriate package "
"manager."
msgstr ""

#: src/installing/source.md:49
msgid "Homebrew (preferred on macOS):"
msgstr ""

#: src/installing/source.md:54
msgid "Apt (preferred on Ubuntu):"
msgstr ""

#: src/installing/source.md:61
msgid "Build the morpho shared library"
msgstr ""

#: src/installing/source.md:63
msgid ""
"The core piece of _morpho_ is a shared library, that can then be used by "
"multiple applications. To build it,"
msgstr ""

#: src/installing/source.md:66 src/installing/source.md:87
#: src/installing/source.md:115
msgid "Obtain the source by cloning the github public repository:"
msgstr ""

#: src/installing/source.md:68
msgid ""
"```\n"
"git clone https://github.com/Morpho-lang/morpho.git\n"
"```"
msgstr ""

#: src/installing/source.md:70
msgid "Navigate to the `morpho` folder and build the library:"
msgstr ""

#: src/installing/source.md:78
msgid "Navigate back out of the morpho folder:"
msgstr ""

#: src/installing/source.md:82
msgid "Build the morpho terminal app"
msgstr ""

#: src/installing/source.md:84
msgid ""
"The terminal app provides an interactive interface to _morpho_, and can also "
"run morpho files."
msgstr ""

#: src/installing/source.md:89
msgid ""
"```\n"
"git clone https://github.com/Morpho-lang/morpho-cli.git\n"
"```"
msgstr ""

#: src/installing/source.md:91 src/installing/source.md:119
msgid "Navigate to the `morpho-cli` folder and build the library:"
msgstr ""

#: src/installing/source.md:99 src/installing/source.md:127
msgid "Check it works by typing:"
msgstr ""

#: src/installing/source.md:103
msgid ""
"Assuming that the morpho terminal app starts correctly, type `quit` to "
"return to the shell and then"
msgstr ""

#: src/installing/source.md:108
msgid "to navigate back out of the morpho-cli folder."
msgstr ""

#: src/installing/source.md:110
msgid "Build the morphoview viewer application"
msgstr ""

#: src/installing/source.md:112
msgid ""
"_Morphoview_ is a simple viewer application to visualize _morpho_ results."
msgstr ""

#: src/installing/source.md:117
msgid ""
"```\n"
"git clone https://github.com/Morpho-lang/morpho-morphoview.git\n"
"```"
msgstr ""

#: src/installing/source.md:131
msgid "which should simply run and quit normally. You can then type"
msgstr ""

#: src/installing/source.md:135
msgid "to navigate back out of the morpho-morphoview folder."
msgstr ""

#: src/installing/wsl.md:3
msgid ""
"Windows support is provided through Windows Subsystem for Linux (WSL), which "
"is an environment that enables windows to run linux applications. We highly "
"recommend using WSL2, which is the most recent version and provides better "
"support for GUI applications; some instructions for WSL1 are provided below."
msgstr ""

#: src/installing/wsl.md:9
msgid ""
"Begin by installing the [Ubuntu App](https://ubuntu.com/desktop/wsl) from "
"the Microsoft store. Follow all the steps in this link to ensure that "
"graphics are working."
msgstr ""

#: src/installing/wsl.md:13
msgid ""
"Once the Ubuntu terminal is working in Windows, you can install _morpho_ "
"either through homebrew or by building from source."
msgstr ""

#: src/installing/wsl.md:16
msgid "Graphics On WSL1"
msgstr ""

#: src/installing/wsl.md:18
msgid ""
"If you instead are working on WSL1, then you need to follow these "
"instructions to get graphics running. Unless mentioned otherwise, all the "
"commands below are run in the Ubuntu terminal."
msgstr ""

#: src/installing/wsl.md:22
msgid ""
"A window manager must be installed so that the WSL can create windows. On "
"Windows, install [VcXsrv](https://sourceforge.net/projects/vcxsrv/). It "
"shows up as XLaunch in the Windows start menu."
msgstr ""

#: src/installing/wsl.md:27
msgid "Open Xlaunch. Then,"
msgstr ""

#: src/installing/wsl.md:29
msgid "choose 'Multiple windows', set display number to 0, and hit 'Next'"
msgstr ""

#: src/installing/wsl.md:32
msgid "choose 'start no client' and hit 'Next'"
msgstr ""

#: src/installing/wsl.md:34
msgid "**Unselect** 'native opengl' and hit 'Next'"
msgstr ""

#: src/installing/wsl.md:36
msgid "Hit 'Finish'"
msgstr ""

#: src/installing/wsl.md:38
msgid ""
"In Ubuntu download a package containing a full suite of desktop utilities "
"that allows for the use of windows."
msgstr ""

#: src/installing/wsl.md:43
msgid "Tell ubuntu which display to use"
msgstr ""

#: src/installing/wsl.md:47
msgid "To set the DISPLAY variable on login type"
msgstr ""

#: src/installing/wsl.md:51
msgid ""
"_\\[Note that this assumes you are using bash as your terminal; you will may "
"to adjust this line for other terminals\\]._"
msgstr ""

#: src/installing/wsl.md:54
msgid "Test that the window system is working by running"
msgstr ""

#: src/installing/wsl.md:58
msgid "which should open a window with some gears."
msgstr ""

#: src/installing/updating.md:3
msgid ""
"As new versions of _morpho_ are released, you will likely want to upgrade to "
"the latest version. From the terminal:"
msgstr ""

#: src/installing/updating.md:6
msgid "If you used homebrew to install morpho, simply type,"
msgstr ""

#: src/installing/updating.md:10
msgid ""
"If you installed _morpho_ manually, and still have the git repository folder "
"on your computer, navigate to this with `cd` and type,"
msgstr ""

#: src/installing/updating.md:16
msgid ""
"which downloads any updates. You can then follow the above instructions to "
"recompile _morpho._ It's not necessary to reinstall dependencies, but note "
"that some new releases of _morpho_ may require additional dependencies."
msgstr ""

#: src/installing/updating.md:21
msgid ""
"If you no longer have the original _morpho_ git repository folder from which "
"you installed morpho, simply rerun the installation from scratch as above. "
"You shouldn't need to reinstall dependencies."
msgstr ""

#: src/installing/uninstalling.md:3
msgid ""
"If you wish to uninstall morpho, you can do so simply from the terminal "
"application."
msgstr ""

#: src/installing/uninstalling.md:6
msgid "If you used homebrew to install morpho, simply type"
msgstr ""

#: src/installing/uninstalling.md:10
msgid ""
"Alternatively, if you built _morpho_ from source, you can remove everything "
"with"
msgstr ""

#: src/installing/uninstalling.md:19
msgid "You may need to prefix these with `sudo`."
msgstr ""

#: src/using_morpho.md:1
msgid "Using _Morpho_"
msgstr ""

#: src/using_morpho.md:3
msgid ""
"_Morpho_ is a command line application, like `python` or `lua`. It can be "
"used to run scripts or programs, which are generally given the _.morpho_ "
"file extension, or run interactively responding to user commands."
msgstr ""

#: src/using_morpho.md:8
msgid "Running a program"
msgstr ""

#: src/using_morpho.md:10
msgid "To run a program, simply run morpho with the name of the file,"
msgstr ""

#: src/using_morpho.md:14
msgid "_Morpho_ supports a number of switches:"
msgstr ""

#: src/using_morpho.md:16
msgid ""
"**\\-w** : Run _morpho_ with more than one worker thread, e.g. `-w 4` runs "
"morpho with 4 threads."
msgstr ""

#: src/using_morpho.md:18
msgid ""
"**\\-D**: Display disassembly of the program without running it. _\\[See "
"developer guide\\]_"
msgstr ""

#: src/using_morpho.md:20
msgid ""
"**\\-d** : Debugging mode. Morpho will stop and enter the debugger whenever "
"a `@` is encountered in the source. _\\[See developer guide\\]_"
msgstr ""

#: src/using_morpho.md:22
msgid ""
"**\\-p** : Profile the program execution. Useful to identify performance "
"bottlenecks. _\\[See developer guide\\]_"
msgstr ""

#: src/using_morpho.md:24
msgid "Interactive mode"
msgstr ""

#: src/using_morpho.md:26
msgid ""
"To use _morpho_ interactively, simply load the _Terminal_ application (or "
"equivalent on your system) and type"
msgstr ""

#: src/using_morpho.md:31
msgid "Command line interface for Morpho"
msgstr ""

#: src/using_morpho.md:32
msgid "![Command line interface for Morpho](./Figures/commandline.jpg)"
msgstr ""

#: src/using_morpho.md:34
msgid ""
"As shown in the figure above, you'll be greeted by a brief welcome and a "
"prompt `>` inviting you to enter _morpho_ commands. For now, try a classic:"
msgstr ""

#: src/using_morpho.md:38 src/reference/nested/graphics.md:227
msgid "\"Hello World\""
msgstr ""

#: src/using_morpho.md:40
msgid ""
"which will display `Hello World` as output. More information about the "
"_morpho_ language is provided in the Reference section, especially chapter "
"[Language](./reference/language.md) if you're familiar with C-like languages "
"such as C, C++, Java, Javascript, etc. things should be quite familiar."
msgstr ""

#: src/using_morpho.md:45
msgid ""
"To assist the user, the contents of the reference manual are available to "
"the user in interactive mode as online help. To get help, simply type:"
msgstr ""

#: src/using_morpho.md:51
msgid "or even more briefly,"
msgstr ""

#: src/using_morpho.md:55
msgid ""
"to see the list of main topics. To find help on a particular topic, for "
"example `for` loops, simply type the topic name afterwards:"
msgstr ""

#: src/using_morpho.md:60
msgid "Once you're done using _morpho_, simply type"
msgstr ""

#: src/using_morpho.md:64
msgid "to exit the program and return to the shell."
msgstr ""

#: src/using_morpho.md:66
msgid ""
"The interactive environment has a few other useful features to assist the "
"user:"
msgstr ""

#: src/using_morpho.md:69
msgid ""
"**Autocomplete.** As you type, _morpho_ will show you any suggested commands "
"that it thinks you're trying to enter. For example, if you type `v` the "
"command line will show the `var` keyword. To accept the suggestion, press "
"the tab key. Multiple suggestions may be available; use the up and down "
"arrow keys to rotate through them."
msgstr ""

#: src/using_morpho.md:75
msgid ""
"**Command history.** Use the arrow keys to retrieve previously entered "
"commands. You may then edit them before running them."
msgstr ""

#: src/using_morpho.md:78
msgid ""
"**Line editing.** As you're typing a command, use the left and right arrows "
"to move the cursor around; you can insert new characters at the cursor just "
"by typing them or delete characters with the `delete` key. Hold down the "
"`shift` key as you use the left and right arrow keys to select text; you can "
"then use` Ctrl-C` to copy and `Ctrl-V` to paste. `Ctrl-A` moves to the start "
"of the line and `Ctrl-E` the end."
msgstr ""

#: src/tutorial.md:3
msgid ""
"To illustrate how to use _morpho_, we will solve a problem involving nematic "
"liquid crystals (NLCs), fluids composed of long, rigid molecules that "
"possess a local average molecular orientation described by a unit vector "
"field \\\\(\\mathbf{n}\\\\). Droplets of NLC immersed in a host isotropic "
"fluid such as water are called _tactoids_ and, unlike droplets of, say, oil "
"in water that form spheres, tactoids can adopt elongated shapes."
msgstr ""

#: src/tutorial.md:11
msgid ""
"The functional to be minimized, the free energy of the system, is quite "
"complex,"
msgstr ""

#: src/tutorial.md:14
msgid ""
"$$ \\\\begin{equation} F= \\underbrace{\\frac{1}{2}\\int\\_{C}"
"K\\_{11}\\left(\\nabla\\cdot\\mathbf{n}\\right)^{2}+K\\_{22}"
"(\\mathbf{n}\\cdot\\nabla\\times\\mathbf{n})^{2}+K\\_{33}\\left|"
"\\mathbf{n}\\times\\nabla\\times\\mathbf{n}\\right|^{2}dA}\\_\\\\text{Liquid "
"crystal elastic energy}\\label{eq:free} \\\\end{equation} $$"
msgstr ""

#: src/tutorial.md:20
msgid ""
"$$ \\\\begin{equation\\*} \\\\quad + \\underbrace{ \\sigma\\int dl }\\_\\"
"\\text{s.t.} \\\\end{equation\\*} $$"
msgstr ""

#: src/tutorial.md:26
msgid ""
"$$ \\\\begin{equation\\*} \\\\quad + \\underbrace{\\frac{W}"
"{2}\\int\\left(\\mathbf{n}\\cdot\\mathbf{t}\\right)^{2}dl}\\_\\"
"\\text{anchoring} \\\\end{equation\\*} $$"
msgstr ""

#: src/tutorial.md:32
msgid ""
"where the three terms include **liquid crystal elasticity** that drives "
"elongation of the droplet, **surface tension** _(s.t.)_ that opposes "
"lengthening of the boundary and an **anchoring term** that imposes a "
"preferred orientation at the boundary. We need a local constraint, \\"
"\\(\\mathbf{n}\\cdot\\mathbf{n}=1\\\\), and will also impose a constraint on "
"the volume of the droplet. For simplicity, we'll solve this problem in 2D. "
"The complete code for this tutorial example is contained in the `examples/"
"tactoid` folder in the repository."
msgstr ""

#: src/tutorial/importing_modules.md:1
msgid "Importing modules"
msgstr ""

#: src/tutorial/importing_modules.md:3
msgid ""
"_Morpho_ is a modular system and hence we typically begin our program by "
"telling _morpho_ the modules we need so that they're available for us to "
"use. To do so, we use the `import` keyword followed by the name of the "
"module:"
msgstr ""

#: src/tutorial/importing_modules.md:12
msgid ""
"We can also use the `import` keyword to import additional program files to "
"assist in modularizing large programs. These are the modules we'll use for "
"this example:"
msgstr ""

#: src/tutorial/importing_modules.md:17
msgid "Module"
msgstr ""

#: src/tutorial/importing_modules.md:17
#: src/tutorial/performing_the_optimization.md:42
msgid "Purpose"
msgstr ""

#: src/tutorial/importing_modules.md:19
msgid "`meshtools`"
msgstr ""

#: src/tutorial/importing_modules.md:19
msgid "Utility code to create and refine meshes"
msgstr ""

#: src/tutorial/importing_modules.md:20
msgid "`optimize`"
msgstr ""

#: src/tutorial/importing_modules.md:20
msgid "Perform optimization"
msgstr ""

#: src/tutorial/importing_modules.md:21
msgid "`plot`"
msgstr ""

#: src/tutorial/importing_modules.md:21
msgid "Visualize results"
msgstr ""

#: src/tutorial/morpho_language.md:1
msgid "Morpho language"
msgstr ""

#: src/tutorial/morpho_language.md:18
msgid ""
"The _morpho_ language is simple but expressive. If you're familiar with C-"
"like languages (C, C++, Java, Javascript) you'll find it very natural. A "
"much more detailed description is provided in Chapter [Language](../"
"reference/language.md), but a brief summary is provided in the above figure "
"and we provide an overview of key ideas to help you follow the tutorial:"
msgstr ""

#: src/tutorial/morpho_language.md:23
msgid ""
"**Comments.** Any text after `//` or surrounded by ```/``*``` and ```*``/``` "
"is a comment and not processed by morpho:"
msgstr ""

#: src/tutorial/morpho_language.md:26
msgid ""
"```\n"
"// This is a comment\n"
"/* This too! */\n"
"```"
msgstr ""

#: src/tutorial/morpho_language.md:29
msgid ""
"**Variables.** To create a variable, use the `var` keyword; you can then "
"assign and use the variable arbitrarily:"
msgstr ""

#: src/tutorial/morpho_language.md:35
msgid ""
"**Functions.** Functions may take parameters, and you call them like this:"
msgstr ""

#: src/tutorial/morpho_language.md:40
msgid "and declare them like this:"
msgstr ""

#: src/tutorial/morpho_language.md:46
msgid "Some functions take optional arguments, which look like this:"
msgstr ""

#: src/tutorial/morpho_language.md:50
msgid ""
"**Objects.** _Morpho_ is deeply object-oriented. Most things in morpho are "
"represented as objects, which provide _methods_ that you can use to control "
"them. Objects are made by _constructor functions_ that begin with a capital "
"letter (and may take arguments):"
msgstr ""

#: src/tutorial/morpho_language.md:57
msgid "Method calls then look like this:"
msgstr ""

#: src/tutorial/morpho_language.md:61
msgid ""
"**Collections.** _Morpho_ provides a number of collection typesall of which "
"are objectsincluding Lists,"
msgstr ""

#: src/tutorial/morpho_language.md:66
msgid "and Dictionaries:"
msgstr ""

#: src/tutorial/morpho_language.md:68
msgid ""
"```\n"
"var b = { \"Massachusetts\": \"Boston\", \"California\": \"Sacramento\" }\n"
"```"
msgstr ""

#: src/tutorial/morpho_language.md:70
msgid "and Ranges (often used in loops):"
msgstr ""

#: src/tutorial/morpho_language.md:74
msgid "There are many others, including Matrices, Sparse matrices, etc."
msgstr ""

#: src/tutorial/creating_the_initial_mesh.md:17
msgid ""
"Meshes are discretized regions of space. The very simplest region we can "
"imagine is a _point_ or _vertex_ described by a set of coordinates \\"
"\\((x\\_{1},x\\_{2},....,x\\_{D})\\\\) where the number of coordinates \\"
"\\(D\\\\) defines the dimensionality of the space that the manifold is said "
"to be _embedded_ in. From more than one point, we can start constructing "
"more complex regions. First, between two points we can imagine fixing an "
"imaginary ruler and drawing a straight line or _edge_ between them. Three "
"points define a plane, and also a triangle; we can therefore identify the "
"two dimensional area of the plane bounded by the triangle as a _face_, as in "
"the face of a polyhedron. Using four points, we can define the volume "
"bounded by a tetrahedron. Each of these **elements** has a different "
"dimensionalitycalled a _grade_and a complete `Mesh` may contain elements of "
"many different grades as shown in Fig. [4.2](#fig:Mesh)."
msgstr ""

#: src/tutorial/creating_the_initial_mesh.md:32
msgid ""
"_Morpho_ provides a number of ways of creating a mesh. One can load a mesh "
"from a file, build one manually from a set of points, create one from a "
"polyhedron, or from the level set (contours) of a function."
msgstr ""

#: src/tutorial/creating_the_initial_mesh.md:36
msgid ""
"For this example, we'll use a predefined mesh file `disk.mesh`. To create a "
"Mesh object from this file, we call the _Mesh_ function with the file name:"
msgstr ""

#: src/tutorial/creating_the_initial_mesh.md:41
#: src/reference/nested/functionals.md:152
msgid "\"disk.mesh\""
msgstr ""

#: src/tutorial/creating_the_initial_mesh.md:44
msgid ""
"Here, the **var** keyword tells morpho to create a new variable _m_, which "
"now refers to the newly created _Mesh_ object. "
msgstr ""

#: src/tutorial/creating_the_initial_mesh.md:56
msgid ""
"The initial mesh is depicted in Fig. [4.3](#fig:InitialMesh); we'll provide "
"the code to perform the visualization in section [Visualizing the results](./"
"visualizing_the_results.md)."
msgstr ""

#: src/tutorial/creating_the_initial_mesh.md:62
msgid ""
"If you open the file `disk.mesh`, which you can find in the same folder as "
"`tactoid.morpho`, you'll find it has a simple human readable format:"
msgstr ""

#: src/tutorial/creating_the_initial_mesh.md:81
msgid ""
"The file is broken into sections, each describing elements of a different "
"grade. Each line begins either with a section delimiter such as _vertices_, "
"_edges_ or _faces_, or with an id. Vertices are then defined by a set of "
"coordinates; edges and faces are defined by providing the respective vertex "
"ids."
msgstr ""

#: src/tutorial/selections.md:3
msgid ""
"Sometimes, we want to refer to specific parts of a `Mesh` object: elements "
"that match some criterion, for example. `Selection` objects enable us to do "
"this. Because selecting the boundary is a very common activity, the "
"`Selection` constructor function takes an optional argument to do this:"
msgstr ""

#: src/tutorial/selections.md:11
msgid ""
"By default, only the boundary elements are included in the `Selection`. For "
"a mesh with at most grade 2 elements (facets), the boundaries are grade 1 "
"elements (lines); for a mesh with grade 3 elements (volumes), the boundaries "
"are grade 2 elements (facets). Quite often we want the vertices themselves "
"as well, so we can call a method to achieve that:"
msgstr ""

#: src/tutorial/selections.md:19
msgid ""
"Once a `Selection` has been created, it can be helpful to visualize it to "
"ensure the correct elements are selected. We'll talk more about "
"visualization in section [Visualizing Results](./visualizing_the_results."
"md), but for now the line"
msgstr ""

#: src/tutorial/selections.md:26
msgid ""
"shows a visualization of the mesh with the selected grade 1 elements shaded "
"red as displayed in Fig. [4.4](#fig:Boundary){reference-type=\"ref\" "
"reference=\"fig:Boundary\"}."
msgstr ""

#: src/tutorial/selections.md:30
msgid ""
"![Selection](../Figures/Tutorial/2Visualize/selection.png) _Selecting the "
"boundary of the mesh_"
msgstr ""

#: src/tutorial/fields.md:3
msgid ""
"Having created our initial computational domain, we will now create a "
"`Field` object representing the director field \\\\(\\mathbf{n}\\\\):"
msgstr ""

#: src/tutorial/fields.md:8
msgid ""
"As with the `Mesh` object earlier, we declare a variable, _nn_, to refer to "
"the `Field` object. We have to provide two arguments to `Field`: the `Mesh` "
"object on which the `Field` is defined, and something to initialize it. "
"Here, we want the initial director to have a spatially uniform value, so we "
"can just provide `Field` a constant `Matrix` object. By default, _morpho_ "
"stores a copy of this matrix on each vertex in the mesh; Fields can however "
"store information on elements of any grade (and store both more than one "
"quantity per grade and information on multiple grades at the same time)."
msgstr ""

#: src/tutorial/fields.md:18
msgid ""
"It's possible to initialize a `Field` with spatially varying values by "
"providing an _anonymous function_ to `Field` like this:"
msgstr ""

#: src/tutorial/fields.md:23
msgid ""
"Here, _phi_ is a scalar field that takes on the value \\\\(x^{2}+y^{2}\\\\). "
"The **fn** keyword is used to define functions."
msgstr ""

#: src/tutorial/defining_the_problem.md:3
msgid ""
"We now turn to setting up the problem. Each term in the energy functional "
"[(1)](../tutorial.md#eq:free) is represented by a corresponding _functional_ "
"object, which acts on a `Mesh` (and possibly a `Field`) to calculate an "
"integral quantity such as an energy; Functional objects are also responsible "
"for calculating gradients of the energy with respect to vertex positions and "
"components of Fields."
msgstr ""

#: src/tutorial/defining_the_problem.md:10
msgid ""
"Let's take the terms in [(1)](../tutorial.md#eq:free) one by one: To "
"represent the nematic elasticity we create a `Nematic` object:"
msgstr ""

#: src/tutorial/defining_the_problem.md:15
msgid ""
"The surface tension term involves the length of the boundary, so we need a "
"`Length` object:"
msgstr ""

#: src/tutorial/defining_the_problem.md:20
msgid ""
"The anchoring term doesn't have a simple built in object type, but we can "
"use a general `LineIntegral` object to achieve the correct result."
msgstr ""

#: src/tutorial/defining_the_problem.md:25
msgid ""
"Notice that we have to supply a functionthe integrandwhich will be called by "
"`LineIntegral` when it evaluates the integral. Integrand functions are "
"called with the local coordinates first (as a `Matrix` object representing a "
"column vector) and then the local interpolated value of any number of "
"`Fields`. We also make use of the special function `tangent()` that locally "
"returns a local tangent to the line."
msgstr ""

#: src/tutorial/defining_the_problem.md:32
msgid ""
"We also need to impose constraints. Any _functional_ object can be used "
"equally well as an energy or a constraint, and hence we create a `NormSq` "
"(norm-squared) object that will be used to implement the local unit vector "
"constraint on the director field:"
msgstr ""

#: src/tutorial/defining_the_problem.md:39
msgid ""
"and an `Area` object for the global constraint. This is really a constraint "
"fixing the volume of fluid in the droplet, but since we're in 2D that "
"becomes a constraint on the area of the mesh:"
msgstr ""

#: src/tutorial/defining_the_problem.md:45
msgid ""
"Now we have a collection of functional objects that we can use to define the "
"problem. So far, we haven't specified which functionals are energies and "
"which are constraints; nor have we specified which parts of the mesh the "
"functionals are to be evaluated over. All that information is collected in "
"an `OptimizationProblem` object, which we will now create:"
msgstr ""

#: src/tutorial/defining_the_problem.md:51
msgid ""
"```\n"
"// Set up the optimization problem\n"
"var W = 1\n"
"var sigma = 1\n"
"\n"
"var problem = OptimizationProblem(m)\n"
"problem.addenergy(lf)\n"
"problem.addenergy(la, selection=bnd, prefactor=-W/2)\n"
"problem.addenergy(lt, selection=bnd, prefactor=sigma)\n"
"problem.addconstraint(laa)\n"
"problem.addlocalconstraint(ln, field=nn, target=1)\n"
"```"
msgstr ""

#: src/tutorial/defining_the_problem.md:62
msgid ""
"Notice that some of these functionals only act on a selection such as the "
"boundary and hence we use the optional `selection` parameter to specify "
"this. We can also specify the prefactor of the functional."
msgstr ""

#: src/tutorial/performing_the_optimization.md:3
msgid ""
"We're now ready to perform the optimization, for which we need an "
"`Optimizer` object. These come in two flavors: a `ShapeOptimizer` and a "
"`FieldOptimizer` that respectively act on the shape and a field. We create "
"them with the problem and quantity they're supposed to act on:"
msgstr ""

#: src/tutorial/performing_the_optimization.md:8
msgid "// Create shape and field optimizers\n"
msgstr ""

#: src/tutorial/performing_the_optimization.md:12
msgid ""
"Having created these, we can perform the optimizion by calling the "
"`linesearch` method with a specified number of iterations for each:"
msgstr ""

#: src/tutorial/performing_the_optimization.md:16
msgid "// Optimization loop\n"
msgstr ""

#: src/tutorial/performing_the_optimization.md:22
msgid ""
"Each iteration of a `linesearch` evolves the field (or shape) down the "
"gradient of the target functional, subject to constraints, and finds an "
"optimal stepsize to reduce the value of the functional. Here, we alternate "
"between optimizing the field and optimizing the shape, performing twenty "
"iterations of each, and overall do this one hundred times. These numbers "
"have been chosen rather arbitrarily, and if you look at the output you will "
"notice that _morpho_ doesn't always execute twenty iterations of each. "
"Rather, at each iteration it checks to see if the change in energy "
"satisfies, $$|E|\\<\\\\epsilon,$$ or, $$\\left|\\frac{\\Delta E}{E}\\right|"
"\\<\\\\epsilon$$ where the value of \\\\(\\epsilon\\\\), the convergence "
"tolerance can be changed by setting the `etol` property of the Optimizer "
"object:"
msgstr ""

#: src/tutorial/performing_the_optimization.md:36
msgid "// default value is 1e-8\n"
msgstr ""

#: src/tutorial/performing_the_optimization.md:38
msgid ""
"Some other properties of an `Optimizer` that may be useful for the user to "
"adjust are as follows:"
msgstr ""

#: src/tutorial/performing_the_optimization.md:42
msgid "Property"
msgstr ""

#: src/tutorial/performing_the_optimization.md:42
msgid "Default value"
msgstr ""

#: src/tutorial/performing_the_optimization.md:44
msgid "`etol`"
msgstr ""

#: src/tutorial/performing_the_optimization.md:44
msgid "\\\\(1\\times10^{-8}\\\\)"
msgstr ""

#: src/tutorial/performing_the_optimization.md:44
msgid "Energy tolerance (relative error)"
msgstr ""

#: src/tutorial/performing_the_optimization.md:45
msgid "`ctol`"
msgstr ""

#: src/tutorial/performing_the_optimization.md:45
msgid "\\\\(1\\times10^{-10}\\\\)"
msgstr ""

#: src/tutorial/performing_the_optimization.md:45
msgid "Constraint tolerance (how well are constraints satisfied)"
msgstr ""

#: src/tutorial/performing_the_optimization.md:46
msgid "`stepsize`"
msgstr ""

#: src/tutorial/performing_the_optimization.md:46
msgid "`0.1`"
msgstr ""

#: src/tutorial/performing_the_optimization.md:46
msgid "Stepsize for `relax` (changed by linesearch)"
msgstr ""

#: src/tutorial/performing_the_optimization.md:47
msgid "`steplimit`"
msgstr ""

#: src/tutorial/performing_the_optimization.md:47
msgid "`0.5`"
msgstr ""

#: src/tutorial/performing_the_optimization.md:47
msgid "Largest stepsize a `linesearch` can take"
msgstr ""

#: src/tutorial/performing_the_optimization.md:48
msgid "`maxconstraintsteps`"
msgstr ""

#: src/tutorial/performing_the_optimization.md:48
msgid "`20`"
msgstr ""

#: src/tutorial/performing_the_optimization.md:48
msgid ""
"Number of steps the optimizer may take to ensure constraints are satisfied"
msgstr ""

#: src/tutorial/performing_the_optimization.md:49
msgid "`quiet`"
msgstr ""

#: src/tutorial/performing_the_optimization.md:49
msgid "`false`"
msgstr ""

#: src/tutorial/performing_the_optimization.md:49
msgid "Whether to print output as the optimization happens"
msgstr ""

#: src/tutorial/visualizing_the_results.md:1
msgid "Visualizing results"
msgstr ""

#: src/tutorial/visualizing_the_results.md:3
msgid ""
"_Morpho_ provides a highly flexible graphics system, with an external viewer "
"application _morphoview_, to enable rich visualizations of results. "
"Visualizations typically involve one or more `Graphics` objects, which act "
"as a container for graphical elements to be displayed. Various _graphics "
"primitives_, such as spheres, cylinders, arrows, tubes, etc. can be added to "
"a `Graphics` object to make a drawing."
msgstr ""

#: src/tutorial/visualizing_the_results.md:11
msgid ""
"We are now ready to visualize the results of the optimization. First, we'll "
"draw the mesh. Because we're interested in seeing the mesh structure, we'll "
"draw the edges (i.e. the grade 1 elements). The function to do this is "
"provided as part of the `plot` module that we imported in section [Importing "
"modules](./importing_modules.md):"
msgstr ""

#: src/tutorial/visualizing_the_results.md:21
msgid ""
"Next, we'll create a separate `Graphics` object that contains the director. "
"Since the director \\\\(\\mathbf{n}\\\\) is a unit vector field, and the "
"sign is not significant (the nematic elastic energy is actually invariant "
"under \\\\(\\mathbf{n}\\to-\\mathbf{n}\\\\)), an appropriate way to display "
"a single director is as a cylinder oriented along \\\\(\\mathbf{n}\\\\). We "
"will therefore make a helper function that creates a `Graphics` object and "
"draws such a cylinder at every mesh point:"
msgstr ""

#: src/tutorial/visualizing_the_results.md:30
msgid ""
"// Function to visualize a director field\n"
"// m - the mesh \n"
"// nn - the director Field to visualize\n"
"// dl - scale the director \n"
msgstr ""

#: src/tutorial/visualizing_the_results.md:36
msgid "// Number of vertices\n"
msgstr ""

#: src/tutorial/visualizing_the_results.md:37
msgid "// Create a graphics object\n"
msgstr ""

#: src/tutorial/visualizing_the_results.md:39
msgid ""
"// Get the ith vertex\n"
"    // Draw a cylinder aligned with nn at this vertex\n"
msgstr ""

#: src/tutorial/visualizing_the_results.md:47
msgid "Once we've defined this function, we can use it:"
msgstr ""

#: src/tutorial/visualizing_the_results.md:53
msgid ""
"The variables \\\\(g\\\\) and \\\\(gnn\\\\) now refer to two separate "
"Graphics objects. We can combine them using the \\\\(+\\\\) operator, and "
"display them like so:"
msgstr ""

#: src/tutorial/visualizing_the_results.md:70
msgid "The resulting visualization is shown in Fig. [4.5](#fig:FinalResult)."
msgstr ""

#: src/tutorial/refinement.md:3
msgid ""
"We have now solved our first shape optimization problem, and the complete "
"problem script is provided in the `examples/tutorial` folder inside the git "
"repository as `tutorial.morpho`. The result we have obtained in Fig. [4.5]"
"(#fig:FinalResult) is, however, a very coarse, low resolution solution "
"comprising only a relatively small number of elements. To gain an improved "
"solution, we need to _refine_ our mesh. Because modifying the mesh also "
"requires us to update other data structures like fields and selections, a "
"special `MeshRefiner` object is used to perform the refinement."
msgstr ""

#: src/tutorial/refinement.md:13
msgid "To perform refinement we:"
msgstr ""

#: src/tutorial/refinement.md:15
msgid ""
"Create a `MeshRefiner` object, providing it a list of all the `Mesh`, "
"`Field` and `Selection` objects (i.e. the mesh and objects that directly "
"depend on it) that need to be updated:"
msgstr ""

#: src/tutorial/refinement.md:19
msgid "// Set the refiner up\n"
msgstr ""

#: src/tutorial/refinement.md:21
msgid ""
"Call the `refine` method on the `MeshRefiner` object to actually perform the "
"refinement. This method returns a `Dictionary` object that maps the old "
"objects to potentially newly created ones."
msgstr ""

#: src/tutorial/refinement.md:25
msgid "// Perform the refinement\n"
msgstr ""

#: src/tutorial/refinement.md:27
msgid ""
"Tell any other objects that refer to the mesh, fields or selections to "
"update their references using `refmap`. For example, `OptimizationProblem` "
"and `Optimizer` objects are typically updated at this step."
msgstr ""

#: src/tutorial/refinement.md:32
msgid "// Update the problem\n"
msgstr ""

#: src/tutorial/refinement.md:34
msgid "Update our own references"
msgstr ""

#: src/tutorial/refinement.md:38
msgid "// Update variables\n"
msgstr ""

#: src/tutorial/refinement.md:51
msgid ""
"We insert this code after our optimization section, which causes _morpho_ to "
"successively optimize and refine."
msgstr ""

#: src/tutorial/refinement.md:54
msgid ""
"The complete code including refinement is in `examples/tutorial` folder "
"inside the git repository as `tutorial2.morpho`"
msgstr ""

#: src/tutorial/refinement.md:56
msgid ""
"The resulting optimized shapes are displayed in Fig. [4.6](#fig:Refinement)."
msgstr ""

#: src/tutorial/refinement.md:59
msgid ""
"```\n"
"// Optimization loop\n"
"var refmax = 3\n"
"for (refiter in 1..refmax) {\n"
"  print \"===Refinement level ${refiter}===\"\n"
"  for (i in 1..100) {\n"
"    fopt.linesearch(20)\n"
"    sopt.linesearch(20)\n"
"  }\n"
"\n"
"  if (refiter==refmax) break\n"
"\n"
"  // Refinement\n"
"  var mr=MeshRefiner([m, nn, bnd]) // Set the refiner up\n"
"  var refmap=mr.refine() // Perform the refinement\n"
"  for (el in [problem, sopt, fopt]) el.update(refmap) // Update the problem\n"
"  m=refmap[m]; nn=refmap[nn]; bnd=refmap[bnd] // Update variables\n"
"}\n"
"```"
msgstr ""

#: src/tutorial/next_steps.md:3
msgid ""
"Having completed this tutorial, you may wish to explore the effect of "
"changing some of the parameters in the file. What happens if you change "
"`sigma` and W, the coefficients in front of the terms in the energy? What "
"happens if you take a different number of steps? Or change properties of the "
"Optimizers like `stepsize` and `steplimit`?"
msgstr ""

#: src/tutorial/next_steps.md:9
msgid ""
"You should look at other example files provided in the `examples` folder of "
"the git repository. The remainder of the manual comprises chapters exploring "
"certain _morpho_ concepts in more detail, followed by a detailed reference "
"manual for _morpho_ functionality, and a complete description of the "
"scripting language."
msgstr ""

#: src/working_with_meshes.md:1
msgid "Working with Meshes"
msgstr ""

#: src/working_with_meshes.md:3
msgid ""
"This chapter explains a number of ways the user can create and manipulate "
"Mesh objects in _morpho_. The simplest way to create a mesh for a desired "
"domain is to use the `meshgen` module, which provides a very high level and "
"convenient interface. The `meshtools` module provides low level mesh "
"creation operations and a number of useful routines to manipulate meshes. "
"The `implicitmesh` module produces surfaces from implicit functions. "
"Finally, you can use an external program to create a mesh that exports the "
"data in vtk format using the `vtk` module."
msgstr ""

#: src/working_with_meshes.md:13
msgid ""
"Mesh creation follows two patterns. Some methods use a **constructor** "
"pattern where you call a single function that creates the Mesh, e.g."
msgstr ""

#: src/working_with_meshes.md:20
msgid ""
"Other approaches follow a **builder** pattern, where you first create a "
"special helper object,"
msgstr ""

#: src/working_with_meshes.md:27
msgid ""
"and manipulate it, e.g. by adding elements or setting options. The Mesh is "
"then created by calling the build method:"
msgstr ""

#: src/working_with_meshes/meshgen_module.md:3
msgid ""
"The `meshgen` module conveniently produces high quality meshes for many "
"kinds of domain. It follows the builder pattern with a MeshGen helper object "
"that performs the construction. To use `meshgen`, the user must provide a "
"scalar function that is positive everywhere that they want to be meshed."
msgstr ""

#: src/working_with_meshes/meshgen_module.md:9
msgid ""
"**Note** One example is referred to in the literature as a _signed distance "
"function_, which is the Euclidean distance of a given point \\\\(x\\\\) to "
"the boundary of a set \\\\(\\Omega\\\\) with the sign positive if \\\\(x\\"
"\\) is in the interior of \\\\(\\Omega\\\\). MeshGen does not require signed "
"distance functions, but accepts any continuous and reasonably smooth "
"function."
msgstr ""

#: src/working_with_meshes/meshgen_module.md:11
msgid ""
"For example, the interior of the unit disk in two dimensions, is described "
"by the function $$f(x,y)=1-(x^{2}+y^{2}).$$ To create the corresponding "
"Mesh, we must first specify a suitable _morpho_ function that describes the "
"domain. This function will be called repeatedly by MeshGen, which will pass "
"it a position vector `x`. Hence, the \\\\((x,y)\\\\) components must be "
"accessed from the argument `x` by indexing:"
msgstr ""

#: src/working_with_meshes/meshgen_module.md:25
msgid "Now that the function is specified, we can create a MeshGen object:"
msgstr ""

#: src/working_with_meshes/meshgen_module.md:31
msgid ""
"The second parameter is a list of Ranges that provide overall bounds on the "
"domain to be meshed. Here we will use \\\\(x,y\\in\\[\\-1,1\\]\\\\). By "
"setting the stepsize, the user can provide MeshGen with an overall "
"suggestion of the resolution."
msgstr ""

#: src/working_with_meshes/meshgen_module.md:36
msgid "Finally, we create the Mesh by calling the build method:"
msgstr ""

#: src/working_with_meshes/meshgen_module.md:42
msgid ""
"The resulting Mesh is shown in Fig. [5.1](#fig:MeshGen-disk), left panel. A "
"higher resolution Mesh can be generated by changing the Range objects passed "
"to MeshGen:"
msgstr ""

#: src/working_with_meshes/meshgen_module.md:48
msgid ""
"This generates a much higher resolution Mesh, with approximately four times "
"the number of vertices as shown in Fig. [5.1](#fig:MeshGen-disk), right "
"panel."
msgstr ""

#: src/working_with_meshes/meshgen_module.md:61
msgid ""
"MeshGen can also mesh more complicated domains. To facilitate this, it "
"provides a Domain class that accepts a scalar function in its constructor. "
"For example, this code creates an ellipse as shown in Fig. [5.2](#fig:"
"MeshGen-2), left panel:"
msgstr ""

#: src/working_with_meshes/meshgen_module.md:71
msgid ""
"The benefit of this is that Domain objects can be combined using set "
"operation methods `union`, `intersection` and `difference`. To illustrate "
"the possibilities with this, we use a special constructor to create three "
"domains corresponding to disks,"
msgstr ""

#: src/working_with_meshes/meshgen_module.md:80
msgid "then combine them,"
msgstr ""

#: src/working_with_meshes/meshgen_module.md:84
msgid "and mesh the resulting domain,"
msgstr ""

#: src/working_with_meshes/meshgen_module.md:89
msgid "with the result shown in Fig. [5.2](#fig:MeshGen-2), right panel."
msgstr ""

#: src/working_with_meshes/meshgen_module.md:101
msgid ""
"Three dimensional meshes are created very similarly. Here we create a "
"spherical mesh, displayed in Fig. [5.3](#fig:MeshGen-3)"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:3
msgid ""
"Meshtools provides many useful functions for working with Meshes, including "
"constructors to create certain kinds of Mesh and also classes for refining, "
"coarsening and merging Meshes."
msgstr ""

#: src/working_with_meshes/meshtools_module.md:7
#: src/reference/nested/meshtools.md:55
msgid "LineMesh"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:9
msgid ""
"The `LineMesh` function is a convenient way to create a Mesh from a one-"
"parameter parametric function. You must specify the function to use and a "
"Range of points to generate. `LineMesh` then evaluates each point in the "
"Range and joins them together with a line element."
msgstr ""

#: src/working_with_meshes/meshtools_module.md:14
msgid ""
"This is useful to generate meshes such as a simple straight line (Fig. [5.4]"
"(#fig:LineMesh), left panel):"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:20
msgid ""
"You can also request the ends of the Mesh be joined together to form a loop "
"by specifying `closed`. This code generates a circle (Fig. [5.4](#fig:"
"LineMesh), center panel):"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:27
msgid ""
"You can increase the resolution of the circle by changing the stepsize in "
"the Range, for example to ```2``*``Pi/20``` to double the number of points. "
"Note the use of the exclusive Range operator here, `...`, rather than `..`to "
"avoid duplicating the point at (1,0)."
msgstr ""

#: src/working_with_meshes/meshtools_module.md:32
msgid ""
"The output Mesh can be of any dimension, such as this helix in 3D (Fig. [5.4]"
"(#fig:LineMesh), right panel). Notice that here we use a regular function "
"rather than an anonymous function:"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:53
#: src/reference/nested/meshtools.md:11
msgid "AreaMesh"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:55
msgid ""
"`AreaMesh` is similar to `LineMesh` function creates a Mesh from a "
"parametric function, which now takes two parameters. To create a square,"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:60
msgid ""
"where notice that a separate Range is required for \\\\(u\\\\) and \\\\(v\\"
"\\). By default, the output of AreaMesh only contains grade 0 and grade 2 "
"elements, i.e. vertices and facets, as is visible in Fig. [5.5](#fig:"
"AreaMesh-1)(left). To add in grade 1 elements if required, call the "
"`addgrade` method on the Mesh:"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:68
msgid "This gives the result shown in Fig. \\[5.5\\](#fig:AreaMesh-1(right)."
msgstr ""

#: src/working_with_meshes/meshtools_module.md:82
msgid ""
"As with LineMesh, the Meshes can be closed in one or both directions, "
"enabling the creation of a cylinder,"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:89
msgid "and a torus,"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:97
msgid ""
"The results of these are displayed in Fig. [5.6](#fig:AreaMesh-2). Note that "
"the meshes generated by more modules that incorporate some degree of quality "
"control, e.g. `implicitmesh` or `meshgen`, are generally better and should "
"be used in preference to those created by AreaMesh."
msgstr ""

#: src/working_with_meshes/meshtools_module.md:112
#: src/reference/nested/meshtools.md:83
msgid "PolyhedronMesh"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:127
msgid ""
"PolyhedronMesh helps to create Meshes corresponding to polyhedra. To make a "
"cube, for example, we specify the eight vertices (see Fig. [5.7](#fig:"
"PolyhedronMesh), left),"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:140
msgid "and the six faces,"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:146
msgid ""
"Note that the vertex ids must be given _in order_ going around each face "
"(see Fig. [5.7](#fig:PolyhedronMesh){reference-type=\"ref\" reference=\"fig:"
"PolyhedronMesh\"}, center). Once the faces are specified, we can create the "
"mesh,"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:154
msgid ""
"Note that PolyhedronMesh automatically creates additional vertices and "
"generates triangles to complete the mesh (Fig. [5.7](#fig:PolyhedronMesh), "
"right). We then added line elements (grade 1) as these are not automatically "
"created by PolyhedronMesh."
msgstr ""

#: src/working_with_meshes/meshtools_module.md:159
#: src/reference/nested/meshtools.md:113
msgid "DelaunayMesh"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:171
msgid ""
"The DelaunayMesh constructor function performs a delaunay \"triangulation\" "
"of a point set. For example, creating a random cloud of points (Fig. [5.8]"
"(#fig:DelaunayMesh), left panel):"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:178
msgid ""
"we can then call DelaunayMesh to construct a tetrahedralization. "
"DelaunayMesh only generates elements of the highest grade (in 2D, area "
"elements, in 3D volume elements) so if edges are needed these can be added "
"with `addgrade`."
msgstr ""

#: src/working_with_meshes/meshtools_module.md:186
msgid ""
"The resulting tetrahedralization is shown in Fig. [5.8](#fig:DelaunayMesh), "
"right panel."
msgstr ""

#: src/working_with_meshes/meshtools_module.md:189
#: src/reference/nested/meshtools.md:147
msgid "ChangeMeshDimension"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:191
msgid ""
"Occasionally, one wishes to take a mesh embedded in one space, say two "
"dimensions, and embed it in a space of different dimensionality. For "
"example, you may wish to use a 2D mesh generated with MeshGen in 3D space. "
"The function `ChangeMeshDimension` provides a convenient way to do this:"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:199
msgid "where `dim` is the target dimension of the new mesh."
msgstr ""

#: src/working_with_meshes/meshtools_module.md:201
#: src/reference/nested/meshtools.md:160
msgid "MeshBuilder"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:203
msgid ""
"The MeshBuilder class facilitates manual construction of a Mesh object. It "
"is primarily intended to be used by other mesh building algorithms, but is "
"occasionally useful. To begin, create a MeshBuilder object:"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:209
msgid ""
"You can then add vertices and other elements one by one by calling "
"appropriate methods. Let's build a tetrahedron by first adding the vertices:"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:218
msgid ""
"We then need to add edges connecting these vertices, and faces as well. We "
"could do this one by one, giving a list of vertex ids for each element in "
"turn,"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:222
msgid ""
"```\n"
"mb.addedge([0,1])\n"
"mb.addedge([0,2]) \n"
"// ... etc. \n"
"```"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:226
msgid ""
"but there's a smarter way for this case. Notice that the vertex ids "
"corresponding to the edges of the tetrahedron correspond to the sets of size "
"2 generated from the list ```[``0,1,2,3``]``` as can be seen by running this "
"code:"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:234
msgid "We can therefore generate the edges automatically,"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:239
msgid "and the faces as well, which are the sets of size 3,"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:243
msgid ""
"We can finish by adding a single grade 3 element corresponding to the volume:"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:248
msgid ""
"Once all these have been added, call the `build` method to create a Mesh "
"object:"
msgstr ""

#: src/working_with_meshes/meshtools_module.md:253
msgid "and the resulting Mesh is shown in Fig. [5.9](#fig:MeshBuilder)."
msgstr ""

#: src/working_with_meshes/vtk_module.md:3
msgid ""
"The vtk module provides importing and exporting facilities for the popular "
"VTK file format, which is used by many other programs such as `paraview`. "
"Unlike morpho _.mesh_ files, VTK files can include both Mesh and Field data. "
"To load a mesh from a VTK file, use a VTKImporter object:"
msgstr ""

#: src/working_with_meshes/vtk_module.md:9
msgid ""
"```\n"
"import vtk \n"
"var mv = VTKImporter(\"file.vtk\")\n"
"var m = mv.mesh()\n"
"```"
msgstr ""

#: src/working_with_meshes/vtk_module.md:13
msgid ""
"Fields can be loaded in a similar way. Each field in the VTK file has an "
"identifier, which is passed to the `field` method as a string."
msgstr ""

#: src/working_with_meshes/vtk_module.md:16
msgid ""
"```\n"
"var f = mv.field(\"F\")\n"
"var g = mv.field(\"G\")\n"
"```"
msgstr ""

#: src/working_with_meshes/vtk_module.md:19
msgid "Exporting requires a VTKExporter class,"
msgstr ""

#: src/working_with_meshes/vtk_module.md:21
msgid ""
"```\n"
"import meshtools \n"
"import vtk \n"
"var m1 = LineMesh(fn (t) [t,0,0], -1..1:2)\n"
"var g1 = Field(m1, fn(x,y,z) Matrix([x,2*x,3*x]))\n"
"\n"
"var vtkE = VTKExporter(g1, fieldname=\"g\")\n"
"vtkE.export(\"data.vtk\")\n"
"```"
msgstr ""

#: src/working_with_meshes/merging_meshes.md:3
msgid ""
"A potential strategy to create meshes for complicated domains is to begin by "
"creating several simpler meshes and then merging them together into one "
"larger mesh. The MeshMerge class in the `meshtools` package allows us to do "
"this. To use it, we create a MeshMerge object with a list of meshes we wish "
"to merge"
msgstr ""

#: src/working_with_meshes/merging_meshes.md:11
msgid ""
"and then call the merge method to perform the merge and return the resulting "
"Mesh:"
msgstr ""

#: src/working_with_meshes/merging_meshes.md:16
msgid ""
"As an example of this, we will build a mesh that might be an initial guess "
"for a membrane held between two square fixed boundaries. We'll do this by "
"creating one octant and then reflecting it along different axes. The basic "
"unit is constructed with PolyhedronMesh, as shown in Fig. [5.11](#fig:"
"MeshMerge):"
msgstr ""

#: src/working_with_meshes/merging_meshes.md:22
msgid ""
"```\n"
"var a = 0.5 // Vertical separation\n"
"var r = 0.5 // Size of hole\n"
"var L = 1  // Size of box \n"
"\n"
"// One octant of the mesh \n"
"var vertices = [ [r,0,a], [L,0,a], [L,r,a], [L,L,a],\n"
"                 [r,L,a], [0,L,a], [0,r,a], [r,r,a],\n"
"                 [r,0,0], [r,r,0], [0,r,0] ]\n"
"var faces = [ [0,1,2,7], [2,3,4,7], [7,4,5,6], [0,8,9,7], [6,7,9,10] ]\n"
"\n"
"var m1 = PolyhedronMesh(vertices, faces)\n"
"m1.addgrade(1)\n"
"```"
msgstr ""

#: src/working_with_meshes/merging_meshes.md:35
msgid ""
"We now need to create code that reflects a Mesh about one or more axes. "
"There's more than one way this could be done, but we will here create a "
"MeshReflector class that follows the builder pattern:"
msgstr ""

#: src/working_with_meshes/merging_meshes.md:39
msgid ""
"```\n"
"class MeshReflector {\n"
"  init(mesh) {\n"
"    self.mesh = mesh\n"
"    self.dim = mesh.vertexmatrix().dimensions()[0] // Get Mesh dimension\n"
"  }\n"
"\n"
"  // Construct a matrix that reflects about one or more axes    \n"
"  _reflectionmatrix(axis) { \n"
"    var rmat = Matrix(self.dim,self.dim)\n"
"    for (i in 0...self.dim) rmat[i,i]=1\n"
"    if (isint(axis)) rmat[axis,axis]*=-1\n"
"    else if (isobject(axis)) for (i in axis) rmat[i,i]*=-1\n"
"    return rmat\n"
"  }\n"
"\n"
"  reflect(axis) { // Reflect the mesh about the given axis or axes\n"
"    var rmat = self._reflectionmatrix(axis)\n"
"    // Clone and transform the mesh\n"
"    var m = self.mesh.clone()\n"
"    for (vid in 0...m.count()) {\n"
"      m.setvertexposition(vid, rmat * m.vertexposition(vid))\n"
"    }\n"
"    return m\n"
"  }\n"
"} \n"
"```"
msgstr ""

#: src/working_with_meshes/merging_meshes.md:65
msgid ""
"Having defined this class, we create a MeshReflector and use it to build "
"seven reflected copies:"
msgstr ""

#: src/working_with_meshes/merging_meshes.md:68
msgid ""
"```\n"
"var mr = MeshReflector(m1)\n"
"\n"
"// Merge reflected meshed together\n"
"var merge = MeshMerge([ m1,\n"
"                        mr.reflect(0),\n"
"                        mr.reflect(1),\n"
"                        mr.reflect(2),\n"
"                        mr.reflect([0,1]),\n"
"                        mr.reflect([1,2]),\n"
"                        mr.reflect([2,0]),\n"
"                        mr.reflect([0,1,2])\n"
"                      ])\n"
"var m = merge.merge()\n"
"```"
msgstr ""

#: src/working_with_meshes/merging_meshes.md:82
msgid ""
"The resulting mesh is shown in Fig. [5.11](#fig:MeshMerge), right panel. "
"Note that MeshMerge automatically removes duplicate elements as the merge is "
"performed, so that"
msgstr ""

#: src/working_with_meshes/merging_meshes.md:89
msgid "reports that there were 35 line elements in the original mesh, while"
msgstr ""

#: src/working_with_meshes/merging_meshes.md:93
msgid ""
"yields \\\\(256=8\\times(35-6/2)\\\\) line elements, because there are 6 "
"shared edges for each copy."
msgstr ""

#: src/working_with_meshes/slicing_meshes.md:3
msgid ""
"The `meshslice` module is designed to help visualize a \"slice\" through the "
"mesh and associated Fields, which is often useful when working with three or "
"higher dimensional meshes. To illustrate its use, we'll reuse the spherical "
"mesh created with MeshGen in the [Meshgen Section](meshgen_module.md) above "
"(see Fig. [5.3](meshgen_module.md#fig:MeshGen-3)). Ensure that the mesh has "
"grade 2 elements present with `addgrade` if necessary. We'll also create a "
"simple scalar field:"
msgstr ""

#: src/working_with_meshes/slicing_meshes.md:13
msgid ""
"To take a slice, first create a MeshSlicer object with the mesh we want to "
"slice:"
msgstr ""

#: src/working_with_meshes/slicing_meshes.md:18
msgid ""
"Then call the `slice` method, which requires us to specify a slicing plane. "
"Planes are defined by a point \\\\((x,y,z)\\\\) and a normal vector \\"
"\\((n\\_{x},n\\_{y},n\\_{z})\\\\), which are passed as arguments:"
msgstr ""

#: src/working_with_meshes/slicing_meshes.md:22
msgid ""
"```\n"
"var slc=ms.slice([0,0,0],[0,0,1]) // position, normal\n"
"```"
msgstr ""

#: src/working_with_meshes/slicing_meshes.md:24
msgid ""
"After taking a slice, we can then slice any number of Field objects as well:"
msgstr ""

#: src/working_with_meshes/slicing_meshes.md:29
msgid ""
"A single MeshSlicer can take any number of slices from the same Mesh; "
"`slicefield` always uses the most recent slice taken. Results from the "
"example are shown in Fig. [5.12](#fig:MeshSlicer). As can be seen, the "
"results of slicing a Mesh typically produce meshes that are quire irregular, "
"with narrow triangles and unequally sized elements. Hence, these meshes are "
"intended mostly for visualization purposes rather than use in calculations."
msgstr ""

#: src/visualization.md:3
msgid ""
"This chapter describes ways to use _morpho_ to visualize output. Easy to use "
"functions to visualize geometric objects are found in the `plot` module, "
"while you can draw arbitrary objects using the `graphics` module. "
"Publication quality output can be generated conveniently using the `povray` "
"module."
msgstr ""

#: src/visualization/plot_module.md:21
msgid ""
"The `plot` module offers a convenient way to visualize Meshes, Fields and "
"Selections. To illustrate its use, we'll create a simple Mesh,"
msgstr ""

#: src/visualization/plot_module.md:28
msgid "and an associated scalar Field,"
msgstr ""

#: src/visualization/plot_module.md:32
msgid "Meshes"
msgstr ""

#: src/visualization/plot_module.md:34
msgid "To visualize the Mesh, use the `plotmesh` function"
msgstr ""

#: src/visualization/plot_module.md:38
msgid ""
"which outputs a Graphics object, which we'll describe more fully in the "
"[Graphics Section](graphics_module.md) below. By default, `plotmesh` shows "
"only the highest grade element presenthere grade 2 or facetsas shown in Fig. "
"[6.1](#fig:PlotMesh)A. To show other grades, use the `grade` option:"
msgstr ""

#: src/visualization/plot_module.md:46
msgid "which shows points and edges as shown in Fig. [6.1](#fig:PlotMesh)B."
msgstr ""

#: src/visualization/plot_module.md:49
msgid ""
"You can control the color of the Mesh with the `color` option as shown in "
"Fig. [6.1](#fig:PlotMesh)C:"
msgstr ""

#: src/visualization/plot_module.md:54
msgid ""
"To display particular selected elements of a mesh, you can use the optional "
"`selection` argument and supply a Selection object."
msgstr ""

#: src/visualization/plot_module.md:61
msgid "Mesh labels"
msgstr ""

#: src/visualization/plot_module.md:77
msgid ""
"It's sometimes helpful to be able to identify the id of a particular element "
"in a Mesh, especially for debugging purposes. The `plotmeshlabels` function "
"is designed to facilitate this as shown in Fig. [6.2](#fig:PlotMeshLabels). "
"You can select which grade to draw ids for and specify their color, size and "
"draw direction. It's also possible to give an offset, which can be a list, "
"matrix or even a function, that adjusts the placement of the labels relative "
"to the center of the element. Here we offset them a little above and to the "
"right:"
msgstr ""

#: src/visualization/plot_module.md:88
msgid ""
"The `plotmeshlabels` function only draws labels, not the mesh itself, so we "
"typically combine it with `plotmesh` and display both:"
msgstr ""

#: src/visualization/plot_module.md:94
msgid "To show the grade 1 element ids, for example, we might use:"
msgstr ""

#: src/visualization/plot_module.md:114
msgid ""
"When setting up a problem in _morpho_, it's very common to use Selection "
"objects to apply Functionals to limited parts of a Mesh. It's essential to "
"check that the Selections are correct, and `plotselection` provides an easy "
"way to do this. To illustrate this, let's select the lower right hand "
"elements in the Mesh,"
msgstr ""

#: src/visualization/plot_module.md:123
msgid ""
"and visualize the Selection as shown in Fig. [6.3](#fig:PlotSelection)A:"
msgstr ""

#: src/visualization/plot_module.md:128
msgid "Similarly, we can select the boundary,"
msgstr ""

#: src/visualization/plot_module.md:132
msgid ""
"and visualize the selection as shown in Fig. [6.3](#fig:PlotSelection)B:"
msgstr ""

#: src/visualization/plot_module.md:139
msgid ""
"Another important use of the `plot` module is to visualize scalar Field "
"objects. To illustrate this, we'll create an AreaMesh that has more points,"
msgstr ""

#: src/visualization/plot_module.md:145
msgid "and a corresponding Field object:"
msgstr ""

#: src/visualization/plot_module.md:149
msgid ""
"It's actually the third lowest energy eigenmode of a square drum, or "
"equivalently the \\\\((1,1)\\\\) state of a 2D infinite square well in "
"quantum mechanics."
msgstr ""

#: src/visualization/plot_module.md:151
msgid ""
"By default, `plotfield` draws points at which the Field is defined, and "
"colors them by the value as in Fig. [6.4](#fig:PlotField)A:"
msgstr ""

#: src/visualization/plot_module.md:157
msgid ""
"Alternatively, `plotfield` can draw higher order elements and interpolate "
"the coloring if you select the style option appropriately as shown in Fig. "
"[6.4](#fig:PlotField)B:"
msgstr ""

#: src/visualization/plot_module.md:161
msgid ""
"```\n"
"var g = plotfield(f, style=\"interpolate\")\n"
"```"
msgstr ""

#: src/visualization/plot_module.md:163
msgid ""
"To aid interpretation of these plots, it's common to display a ScaleBar "
"object alongside the plot. These have quite a few options, including the "
"position and size, as well as the number of ticks and text layout."
msgstr ""

#: src/visualization/plot_module.md:169
msgid ""
"The scalebar is the then supplied as an optional argument to `plotfield`. "
"Here, we also use a different colormap object:"
msgstr ""

#: src/visualization/plot_module.md:172
msgid ""
"```\n"
"var g = plotfield(f, style=\"interpolate\", scalebar=sb, "
"colormap=PlasmaMap())\n"
"```"
msgstr ""

#: src/visualization/plot_module.md:174
msgid ""
"The `color` module supplies a number of colormaps that you can try: "
"ViridisMap is used by default, but PlasmaMap, MagmaMap and InfernoMap are "
"also recommended and have been specially formulated to be accessible to "
"users with limited color perception."
msgstr ""

#: src/visualization/plot_module.md:179
msgid ""
"The _morpho_ versions are adapted from _Simon Garnier, Noam Ross, Robert "
"Rudis, Antônio P. Camargo, Marco Sciaini, and Cédric Scherer (2021). "
"viridis(Lite) - Colorblind-Friendly Color Maps for R. viridis package "
"version 0.6.2._"
msgstr ""

#: src/visualization/plot_module.md:181
msgid "GrayMap and HueMap are also available."
msgstr ""

#: src/visualization/graphics_module.md:3
msgid ""
"Support for low level graphics is provided by the `graphics` module, which "
"you can use this to create custom visualizations and generate other kinds of "
"graphical output. These can be easily combined with output from the `plot` "
"module, which utilizes `graphics` internally."
msgstr ""

#: src/visualization/graphics_module.md:8
msgid ""
"We begin by creating a Graphics object, which represents a _scene_ or a "
"collection of things to be displayed."
msgstr ""

#: src/visualization/graphics_module.md:13
msgid ""
"Once the Graphics object is created, we can add _display elements_, objects "
"specifying what is to be drawn, to the scene in turn."
msgstr ""

#: src/visualization/graphics_module.md:16
msgid "Sometimes referred to as graphics 'primitives'."
msgstr ""

#: src/visualization/graphics_module.md:18
msgid "The graphics module supports the following kinds of element:"
msgstr ""

#: src/visualization/graphics_module.md:20
msgid ""
"**Cylinder** specified by two points at each end of the cylinder on its "
"axis. You can also specify the aspect ratio, i.e. the ratio of the radius of "
"the cylinder to its length, and the number of points to draw."
msgstr ""

#: src/visualization/graphics_module.md:27
msgid "**Arrow** specified in the same way as a Cylinder, e.g."
msgstr ""

#: src/visualization/graphics_module.md:31
msgid "**Sphere** specified by the center and the radius, e.g."
msgstr ""

#: src/visualization/graphics_module.md:35
msgid ""
"**Text** specified by the text to display and the location to display at. "
"Many options can be provided, including the drawing direction and the "
"vertical direction, the size in points (1 graphics unit=72 points), and the "
"Font."
msgstr ""

#: src/visualization/graphics_module.md:40
msgid ""
"```\n"
"Text(\"Hello World!\", [-0.75,0,0], size=24, color=Black)\n"
"```"
msgstr ""

#: src/visualization/graphics_module.md:42
msgid ""
"**Tube** specified by a sequence of points and a radius. You can also "
"specify if the tube is closed or not."
msgstr ""

#: src/visualization/graphics_module.md:51
msgid ""
"**TriangleComplex** describes a collection of triangles, which can be used "
"to display polyhedra and other complex objects. These elements are low-"
"level, and further information is available in the reference section."
msgstr ""

#: src/visualization/graphics_module.md:56
msgid "Most of these elements accept certain optional arguments:"
msgstr ""

#: src/visualization/graphics_module.md:58
msgid "**color** to specify the color."
msgstr ""

#: src/visualization/graphics_module.md:60
msgid ""
"**transmit** specifies the transparency of the element, which by default is "
"0."
msgstr ""

#: src/visualization/graphics_module.md:63
msgid ""
"**filter** alternative way of specifying transparency for use with the "
"povray module."
msgstr ""

#: src/visualization/graphics_module.md:66
msgid ""
"Once appropriate elements have been created, we can display the Graphics "
"object with `morphoview` using Show."
msgstr ""

#: src/visualization/graphics_module.md:97
msgid "Example: Visualizing an electric field"
msgstr ""

#: src/visualization/graphics_module.md:110
msgid ""
"As an illustration of what's possible using the `graphics` module directly, "
"we'll create a visualization of the electric field due to two point charges "
"(Fig. [6.6](#fig:ElectricField){reference-type=\"ref\" reference=\"fig:"
"ElectricField\"}). Begin by setting some constants and creating the Graphics "
"object:"
msgstr ""

#: src/visualization/graphics_module.md:116
msgid ""
"```\n"
"var L = 2 // Size of domain to draw\n"
"var R = 1 // Separation of the charges\n"
"var dx = 0.125 // Spacing of points to draw\n"
"var eps = 1e-10 // Check for zero separation\n"
"\n"
"var g = Graphics()\n"
"```"
msgstr ""

#: src/visualization/graphics_module.md:123
msgid ""
"We'll now define the charges by creating two List objects: one contains the "
"strength of each charge and the second stores their positions:"
msgstr ""

#: src/visualization/graphics_module.md:126
msgid ""
"```\n"
"// Electric field due to a system of point charges\n"
"var qq = [1,-1]\n"
"var xq = [ Matrix([-R/2, 0, 0]), Matrix([R/2, 0, 0])]\n"
"```"
msgstr ""

#: src/visualization/graphics_module.md:130
msgid ""
"We'll also define a cutoff distance around each charge below which we won't "
"draw the electric field (remember it grows \\\\(\\to\\infty\\\\) as we get "
"closer!):"
msgstr ""

#: src/visualization/graphics_module.md:136
msgid ""
"Next, we need a function that calculates the electric field at an arbitary "
"point. We do this by summing up the electric fields due to each charge using "
"Coulomb's law:"
msgstr ""

#: src/visualization/graphics_module.md:140
msgid ""
"```\n"
"fn efield(x) {\n"
"   var e = 0\n"
"   for (q, k in qq) {\n"
"    var r=x-xq[k]\n"
"    if (r.norm()<cutoff) return nil\n"
"    e+=q*r/(r.norm()^3) // = 1/r^2 * \\hat{r}\n"
"  }\n"
"  return e\n"
" }\n"
"```"
msgstr ""

#: src/visualization/graphics_module.md:150
msgid ""
"To draw the electric field, we create a rectangular grid of points, "
"calculate the electric field at each point and draw an Arrow along the "
"orientation."
msgstr ""

#: src/visualization/graphics_module.md:162
msgid "We now draw the charges, coloring them by their sign:"
msgstr ""

#: src/visualization/graphics_module.md:170
msgid "Finally, we display the scene:"
msgstr ""

#: src/visualization/povray_module.md:3
msgid ""
"All figures in this manual have been exported directly from the _morpho_ "
"programs that created them using the persistence of vision raytracer or "
"`povray`. A raytracer is a program that takes a scene description and "
"renders graphical output by tracing the path of individual rays of light. "
"Because the model of light propagation and image formation is physically "
"motivated, the output is of very high quality. By contrast, `morphoview` and "
"most graphics programs use simplified approximate rendering techniques that "
"enable real time interactive output. At the time of writing, raytracing is "
"gaining popularity as a technique, and some high performance graphics cards "
"now have real time raytracing capability. `povray` is a very well "
"established program that is widely available and cross platform."
msgstr ""

#: src/visualization/povray_module.md:16
msgid ""
"To use the `povray` module, you need to create a POVRaytracer object and "
"initialize it with the graphics object"
msgstr ""

#: src/visualization/povray_module.md:23
msgid ""
"You can choose features of the graphics out by setting properties of this "
"object, for example:"
msgstr ""

#: src/visualization/povray_module.md:26
msgid ""
"```\n"
"pov.viewpoint = Matrix([5,5,6]) // Sets where the camera is located\n"
"pov.viewangle = 18 // Controls the angular size of the view\n"
"pov.background = White // Sets the background for rendering\n"
"pov.light=[Matrix([10,10,10]), Matrix([0,0,10]), Matrix([-10,-10,10])] // "
"Places light point sources at several positions\n"
"```"
msgstr ""

#: src/visualization/povray_module.md:31
msgid ""
"Because the list of properties can get quite cumbersome, it's possible to "
"specify them through a separate Camera object and initialize the raytracer "
"to use the Camera:"
msgstr ""

#: src/visualization/povray_module.md:37
msgid "See the Reference section for further details."
msgstr ""

#: src/visualization/povray_module.md:39
msgid ""
"To produce output, call the render method to create a .pov file and run "
"povray:"
msgstr ""

#: src/visualization/povray_module.md:42
msgid ""
"```\n"
"pov.render(\"graphic.pov\")\n"
"```"
msgstr ""

#: src/visualization/povray_module.md:44
msgid ""
"By default, the resulting .png file is opened. You can stop this by calling "
"render with `display` set to `false`:"
msgstr ""

#: src/visualization/povray_module.md:47
msgid ""
"```\n"
"pov.render(\"graphic.pov\", display=false)\n"
"```"
msgstr ""

#: src/visualization/povray_module.md:49
msgid ""
"If you wish to simply create .pov file without running povray, use the write "
"method:"
msgstr ""

#: src/visualization/povray_module.md:52
msgid ""
"```\n"
"pov.write(\"graphic.pov\")\n"
"```"
msgstr ""

#: src/visualization/povray_module.md:64
msgid ""
"A major advantage of raytracing is natural support for transparency effects. "
"Here we generate 50 spheres of random placement, size and transparency by "
"setting the `transmit` option. The rendered output is shown in Fig. [6.7]"
"(#fig:Transparency)."
msgstr ""

#: src/examples.md:3
msgid ""
"This chapter discusses the example programs provided to illustrate various "
"_morpho_ features. These can be found in the `examples` folder of the morpho "
"git repository and are listed here in alphabetical order. Some closely "
"relate to material presented in other chapters for which cross-references "
"are provided."
msgstr ""

#: src/examples/catenoid.md:16
msgid ""
"A soap film held between two parallel concentric circular rings adopts the "
"shape of a minimal surface called a _catenoid._ This is a relatively simple "
"optimization problem, and hence is a good example for beginners to _morpho_."
msgstr ""

#: src/examples/catenoid.md:21
msgid "The initial mesh is created using AreaMesh in the `meshtools` module:"
msgstr ""

#: src/examples/catenoid.md:23
msgid ""
"```\n"
"var r = 1.0 // radius\n"
"var ratio = 0.4 // Separation to diameter ratio\n"
"var L = 2*r*ratio // Separation\n"
"\n"
"// Generate a tube / cylindrical mesh\n"
"var mesh = AreaMesh(fn (u, v) [r*cos(u), v, r*sin(u)],\n"
"                    -Pi...Pi:Pi/10,\n"
"                    -L/2..L/2:L/5,\n"
"                    closed=[true,false] )\n"
"mesh.addgrade(1)\n"
"```"
msgstr ""

#: src/examples/catenoid.md:34
msgid ""
"The boundary of the mesh must be fixed in place. We can do this by creating "
"a Selection, and visualizing it as shown in Fig. [7.1](#fig:Catenoid), left "
"panel:"
msgstr ""

#: src/examples/catenoid.md:39
msgid ""
"```\n"
"// Select the boundary\n"
"var bnd = Selection(mesh, boundary=true)\n"
"var g = plotselection(mesh, bnd, grade=1) \n"
"```"
msgstr ""

#: src/examples/catenoid.md:43
msgid ""
"The optimization problem simply requires us to specify the area as the "
"quantity to minimize:"
msgstr ""

#: src/examples/catenoid.md:46
msgid ""
"```\n"
" // Define the optimizataion problem\n"
"var problem = OptimizationProblem(mesh) \n"
"// Add the area energy using the built-in Area functional\n"
"var area = Area()\n"
"problem.addenergy(area) \n"
"```"
msgstr ""

#: src/examples/catenoid.md:52
msgid "We then create a ShapeOptimizer to perform the optimization,"
msgstr ""

#: src/examples/catenoid.md:56
msgid "fix the boundary elements using the selection object we created,"
msgstr ""

#: src/examples/catenoid.md:60
msgid ""
"and perform the optimization. Conjugate gradient works well for this problem "
"and converges in a few iterations. The final optimized shape is shown in "
"Fig. [7.1](#fig:Catenoid), right panel."
msgstr ""

#: src/examples/cholesteric.md:3
msgid ""
"A cholesteric liquid crystal, in contrast to a nematic liquid crystal as was "
"considered in the tutorial in Chapter X, favors a twisted state. The liquid "
"crystal elastic energy is modified to include a preferred chiral wavevector "
"\\\\(q\\_{0}\\\\), $$ \\\\begin{equation} F=\\frac{1}{2}\\int\\_{C}"
"K\\_{11}\\left(\\nabla\\cdot\\mathbf{n}\\right)^{2}+K\\_{22}"
"(\\mathbf{n}\\cdot\\nabla\\times\\mathbf{n}-q\\_{0})^{2}+K\\_{33}\\left|"
"\\mathbf{n}\\times\\nabla\\times\\mathbf{n}\\right|^{2}dA.\\label{eq:"
"CholestericFreeEnergy} \\\\end{equation} $$ The cholesteric example "
"minimizes the above equation in a square domain \\\\((x,y)\\in\\[\\-L,L\\]\\"
"\\), with \\\\(L=1/2\\\\), together with an anchoring energy, $"
"$W\\int(\\mathbf{n}\\cdot\\mathbf{\\hat{y}})^{2}dl,$$ imposed on the top and "
"bottom boundaries to promote _planar degenerate_ alignment, i.e. \\"
"\\(\\mathbf{n}\\\\) prefers to lie any direction in the \\\\(x-z\\\\) plane. "
"The optimized structure with \\\\(q\\_{0}=\\pi/2\\\\) is displayed in Fig. "
"([7.2](#fig:Cholesteric))."
msgstr ""

#: src/examples/cube.md:16
msgid ""
"This example finds a minimal surface with fixed enclosed volume, i.e. a "
"sphere. It closely parallels a similar example from _Surface Evolver_, and "
"hence may aid those familiar with that program in learning to use _morpho_. "
"Starting from an initial cube, shown in Fig. ([7.3](#fig:Cube)), and created "
"as follows:"
msgstr ""

#: src/examples/cube.md:23
msgid ""
"```\n"
" // Create an initial cube\n"
"var m = PolyhedronMesh([ [-0.5, -0.5, -0.5],\n"
"                         [ 0.5, -0.5, -0.5],\n"
"                         [-0.5,  0.5, -0.5],\n"
"                         [ 0.5,  0.5, -0.5],\n"
"                         [-0.5, -0.5,  0.5],\n"
"                         [ 0.5, -0.5,  0.5],\n"
"                         [-0.5,  0.5,  0.5],\n"
"                         [ 0.5,  0.5,  0.5]],\n"
"                       [ [0,1,3,2], [4,5,7,6],\n"
"                         [0,1,5,4], [3,2,6,7],\n"
"                         [0,2,6,4], [1,3,7,5] ])\n"
"```"
msgstr ""

#: src/examples/cube.md:36
msgid "The problem and optimizer are set up:"
msgstr ""

#: src/examples/cube.md:47
msgid "The mesh is optimized, then refined, then reoptimized:"
msgstr ""

#: src/examples/cube.md:49
msgid ""
"```\n"
"var Nlevels = 4 // Levels of refinement\n"
"var Nsteps = 1000 // Maximum number of steps per refinement level\n"
"\n"
"for (i in 1..Nlevels) {\n"
"  opt.conjugategradient(Nsteps)\n"
"  if (i==Nlevels) break\n"
"  // Refine\n"
"  var mr=MeshRefiner([m])\n"
"  var refmap = mr.refine()\n"
"  for (el in [problem, opt]) el.update(refmap)\n"
"  m = refmap[m]\n"
"}\n"
"```"
msgstr ""

#: src/examples/cube.md:62
msgid ""
"And finally the resulting area is compared with the true area of a sphere at "
"the same volume:"
msgstr ""

#: src/examples/cube.md:65
msgid ""
"```\n"
"var V0=lv.total(m)\n"
"var Af=la.total(m)\n"
"var R=(V0/(4/3*Pi))^(1/3)\n"
"var area = 4*Pi*R^2\n"
"print \"Final area: ${Af} True area: ${area} diff: ${abs(Af-area)}\"\n"
"```"
msgstr ""

#: src/examples/delaunay.md:16
msgid ""
"This example demonstrates use of the `delaunay` module to create a Delaunay "
"triangulation from a point cloud. The triangulation generated is explicitly "
"checked for the property that no point other than the vertices lies within "
"the circumsphere of each triangle."
msgstr ""

#: src/examples/dla.md:11
msgid ""
"Diffusion Limited Aggregation is a process describing the formation of "
"aggregates of sticky particles. An initial seed particle of radius \\\\(r\\"
"\\) is placed at \\\\( x_0=(0,0,0) \\\\). Subsequent particles are added one "
"by one from initial random points \\\\(\\mathbf{x}\\_{i}^{0}"
"=R\\mathbf{\\xi}/|\\mathbf{\\xi}|\\\\) where \\\\(\\xi\\\\) is a random "
"point normally distributed in each axis; the construction \\"
"\\(\\mathbf{\\xi}/|\\mathbf{\\xi}|\\\\) generates a random point on the unit "
"sphere. In _morpho_, this looks like"
msgstr ""

#: src/examples/dla.md:25
msgid "The mobile particle moves diffusively, according to"
msgstr ""

#: src/examples/dla.md:27
msgid "$$ x_i^{n+1}=x_i^{n}+\\delta\\xi$$ "
msgstr ""

#: src/examples/dla.md:29
msgid ""
"where \\\\(\\delta\\\\) is a small number. As the particle moves, we check "
"to see if it has collided with any other particles, $$\\left|x\\_{i}-"
"x\\_{j}\\right|\\<2r,\\forall i\\neq j,\\label{eq:collisioncheck}$$ or if it "
"has wandered out of bounds, $$\\left|x\\_{i}\\right|>2R.$$ If a particle has "
"collided with another particle, it becomes fixed in place and joins the "
"aggregate. As particles are added, the aggregate develops a characteristic "
"fractalline morphology as shown in Fig. [7.5](#fig:DLA){reference-"
"type=\"ref\" reference=\"fig:DLA\"}. The body of the program is a double "
"loop:"
msgstr ""

#: src/examples/dla.md:40
msgid ""
"```\n"
"for (n in 1..Np) { // Add particles one-by-one  \n"
"  var x = randompt()\n"
"  while (true) {\n"
"    // Move current particle\n"
"    x+=Matrix([delta*randomnormal(), delta*randomnormal(), "
"delta*randomnormal()])\n"
"\n"
"    // Check for collisions\n"
"    /* ... */\n"
"\n"
"    // Catch if it wandered out of the boundary\n"
"    if (x.norm()>2*R) x = randompt() \n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/examples/dla.md:54
msgid ""
"To perform the collision check, the example uses a data structure called a \\"
"\\(k\\\\)-dimensional tree, provided in the `kdtree` module. A \\\\(k\\\\)-"
"dimensional tree provides a nearest neighbor search with \\\\(O(\\log N)\\"
"\\) complexity rather than \\\\(O(N)\\\\) complexity as would be required by "
"searching all the points directly. The collision check code looks like this:"
msgstr ""

#: src/examples/dla.md:61
msgid ""
"```\n"
"if ((tree.nearest(x).location-x).norm()<2*r) {\n"
"  tree.insert(x)\n"
"  pts.append(x)\n"
"  if (x.norm()>R/2) R = 2*x.norm()\n"
"  break // Move to next particle\n"
"}\n"
"```"
msgstr ""

#: src/examples/dla.md:68
msgid ""
"Notice that we gradually expand \\\\(R\\\\) as the aggregate grows. Ideally, "
"each point should start very far away, really at infinity, but this would be "
"very expensive in terms of the number of diffusion steps. A value of \\\\(R\\"
"\\) double the greatest extent of the aggregate is a good compromise between "
"speed and a reasonable approximation of diffusion limited aggregation."
msgstr ""

#: src/examples/dla.md:75
msgid ""
"This example also demonstrates how to create a simple custom visualization "
"directly using the `graphics `module. The particles are drawn as spheres and "
"displayed with the following code. An example run is displayed in Fig. [7.5]"
"(#fig:DLA)."
msgstr ""

#: src/examples/electrostatics.md:3
msgid ""
"This example shows how to solve a simple electrostatics problem with "
"adaptive refinement, and provides a useful example of how to cast a problem "
"that is normally thought of as solving a PDE as an optimization problem."
msgstr ""

#: src/examples/electrostatics.md:8
msgid "Suppose we want to solve Laplace's equation,"
msgstr ""

#: src/examples/electrostatics.md:10
msgid "$$\\nabla^{2}\\phi=0$$"
msgstr ""

#: src/examples/electrostatics.md:12
msgid ""
"on a square domain \\\\(C\\\\) defined by \\\\(-L/2\\leq x\\leq L/2\\\\) and "
"\\\\(-L/2\\leq y\\leq L/2\\\\). An equivalent formulation suitable for "
"_morpho_ is to minimize,"
msgstr ""

#: src/examples/electrostatics.md:16
msgid ""
"$$ \\\\begin{equation} \\\\int\\_{C}\\left|\\nabla\\phi\\right|^{2}dA \\"
"\\label{eq:el1} \\\\end{equation} $$"
msgstr ""

#: src/examples/electrostatics.md:23
msgid "with respect to \\\\(\\phi\\\\)."
msgstr ""

#: src/examples/electrostatics.md:25
msgid ""
"We can show the two are equivalent by applying calculus of variations to the "
"\\eqref{eq:el1},"
msgstr ""

#: src/examples/electrostatics.md:28
msgid ""
"$$ \\delta\\int\\*{C}\\left|\\nabla\\phi\\right|^{2}dA "
"=\\int\\*{C}\\delta\\left|\\nabla\\phi\\right|^{2}dA $$ $$ "
"=\\int\\_{C}\\frac{\\partial}{\\partial\\nabla\\phi}\\left|"
"\\nabla\\phi\\right|^{2}\\cdot\\delta\\nabla\\phi dA,$$"
msgstr ""

#: src/examples/electrostatics.md:31
msgid "and integrating by parts,"
msgstr ""

#: src/examples/electrostatics.md:33
msgid ""
"$$ \\\\begin{align} \\\\int\\_{C}\\frac{\\partial}"
"{\\partial\\nabla\\phi}\\left|\\nabla\\phi\\right|"
"^{2}\\cdot\\delta\\nabla\\phi dA & =\\int\\_{\\partial "
"C}\\nabla\\phi\\cdot\\hat{\\mathbf{s}}\\delta\\phi dl-"
"\\int\\_{C}\\nabla\\cdot\\frac{\\partial}{\\partial\\nabla\\phi}\\left|"
"\\nabla\\phi\\right|^{2}\\delta\\phi dA\\nonumber \\\\\\\\ & "
"=\\int\\_{\\partial C}\\nabla\\phi\\cdot\\hat{\\mathbf{s}}\\delta\\phi dl-"
"\\int\\_{C}\\nabla^{2}\\phi\\delta\\phi dA,\\label{eq:bulkvariations} \\"
"\\end{align} $$"
msgstr ""

#: src/examples/electrostatics.md:40
msgid ""
"**Note** If you're not familiar with calculus of variations, feel free to "
"skip paragraphs that refer to \"variations\". The calculus of variations "
"generalizes calculus from differentiating with respect to variables to "
"differentiating with respect to functions."
msgstr ""

#: src/examples/electrostatics.md:42
msgid ""
"where \\\\(\\hat{\\mathbf{s}}\\\\) is the outward normal. Hence, allowing "
"for arbitrary variations \\\\(\\delta\\phi\\\\), in order for the bulk "
"integrand to vanish Laplace's equation \\\\(\\nabla^{2}\\phi=0\\\\) must be "
"satisfied. Similarly requiring the boundary integrand to vanish yields the "
"\"natural\" boundary condition \\\\(\\nabla\\phi\\cdot\\hat{\\mathbf{s}}=0\\"
"\\), known as the Neumann boundary condition. In the absence of boundary "
"energies, solving \\\\(\\nabla^{2}\\phi=0\\\\) in \\\\(C\\\\) subject to \\"
"\\(\\nabla\\phi\\cdot\\hat{\\mathbf{s}}=0\\\\) on \\\\(\\partial C\\\\) "
"yields the family of uniform constant solutions \\\\(\\phi=\\text{const}.\\"
"\\)"
msgstr ""

#: src/examples/electrostatics.md:52
msgid ""
"To impose boundary data, we will supplement \\eqref{eq:el1} with the "
"additional functional,"
msgstr ""

#: src/examples/electrostatics.md:55
msgid ""
"$$ \\\\begin{equation} \\\\lambda\\int\\_{\\partial C}\\left\\[\\\\phi-"
"\\phi\\_{0}(\\mathbf{x})\\right\\]^{2}dl\\label{eq:anchoring} \\"
"\\end{equation} $$"
msgstr ""

#: src/examples/electrostatics.md:61
msgid ""
"where the function \\\\(\\phi\\_{0}\\\\) represents some imposed boundary "
"potential. Taking variations of this functional,"
msgstr ""

#: src/examples/electrostatics.md:64
msgid ""
"$$ \\\\begin{align} \\\\delta\\lambda\\int\\_{\\partial C}\\left\\[\\\\phi-"
"\\phi\\_{0}(\\mathbf{x})\\right\\]^{2}dl & =\\lambda\\int\\_{\\partial "
"C}\\frac{\\partial}{\\partial\\phi}\\left\\[\\\\phi-\\phi\\_{0}"
"(\\mathbf{x})\\right\\]^{2}\\delta\\phi dl\\nonumber \\\\\\\\ & "
"=\\lambda\\int\\_{\\partial C}2\\left\\[\\\\phi-\\phi\\_{0}"
"(\\mathbf{x})\\right\\]\\\\delta\\phi dl\\label{eq:boundary} \\\\end{align} $"
"$"
msgstr ""

#: src/examples/electrostatics.md:71
msgid ""
"Collecting the boundary terms from \\eqref{eq:bulkvariations} and \\eqref{eq:"
"boundary}, we obtain the equivalent boundary condition on \\\\(\\phi\\\\), $$"
"\\nabla\\phi\\cdot\\hat{\\mathbf{s}}+2\\lambda(\\phi-\\phi\\_{0})=0,$$ which "
"is known as a Robin boundary condition. As \\\\(\\lambda\\to\\infty\\\\), \\"
"\\(\\phi\\to\\phi_0\\\\) on the boundary, recovering a fixed boundary or "
"Dirichlet condition, while as \\\\(\\lambda\\to0\\\\), we recover the "
"Neumann conditions discussed earlier."
msgstr ""

#: src/examples/electrostatics.md:79
msgid ""
"In the example, we will set \\\\(\\phi_0=0\\\\) on the left and lower "
"boundary and \\\\(\\phi_0=1\\\\) on the right and upper boundary, and use \\"
"\\(\\lambda=100\\\\)."
msgstr ""

#: src/examples/electrostatics.md:82
msgid ""
"The code illustrates a few _morpho_ tricks. First, the following code is "
"used to select the left/bottom and upper/right sides of the mesh:"
msgstr ""

#: src/examples/electrostatics.md:92
msgid ""
"What's happening here is that we select the whole boundary in the first line "
"and then select relevant vertices in the next two lines. The edges are then "
"added to the selection with `addgrade`, but this also selects some interior "
"edges. To ensure we only have boundary edges in our selections, we find the "
"intersection of `bnd1` and `bnd`, and similarly for `bnd2`."
msgstr ""

#: src/examples/electrostatics.md:99
msgid ""
"The problem setup involves adding the electrostatic energy Eq.\\eqref{eq:"
"el1} using `GradSq` and the boundary terms Eq.\\eqref{eq:anchoring} as "
"`LineIntegral`s."
msgstr ""

#: src/examples/electrostatics.md:111
msgid "Optimization is done with a `FieldOptimizer`:"
msgstr ""

#: src/examples/electrostatics.md:116
msgid ""
"The problem as posed requires \\\\(\\phi\\\\) to very sharply change in the "
"upper left and lower right cornes as the imposed potential changes, but far "
"away from these \\\\(\\phi\\\\) changes much more slowly. We would like "
"therefore to perform _adaptive refinement_, refining the mesh only in places "
"where \\\\(\\phi\\\\) is rapidly changing and using coarse elements "
"elsewhere."
msgstr ""

#: src/examples/electrostatics.md:122
msgid ""
"To identify elements to refine, we compute the electrostatic energy in each "
"elementwe'll use this as a heuristic measure of how rapidly \\\\(\\phi\\\\) "
"is changingand find the mean energy per element. We then create a Selection "
"and manually select elements that have an electrostatic energy more than \\"
"\\(1.5\\times\\\\) the mean."
msgstr ""

#: src/examples/electrostatics.md:128
msgid ""
"```\n"
"// Select elements that have an above average contribution to the energy\n"
"var en = le.integrand(phi) // energy in each element\n"
"var mean = en.sum()/en.count() // mean energy per element\n"
"var srefine = Selection(mesh)\n"
"for (id in 0...en.count()) if (en[0,id]>1.5*mean) srefine[2,id]=true\n"
"// identify large contributions\n"
"```"
msgstr ""

#: src/examples/electrostatics.md:135
msgid ""
"Refinement is then performed with a MeshRefiner object from the `meshtools` "
"module, which we create with a list of both the mesh to refine _and_ all "
"quantities that refer to the mesh:"
msgstr ""

#: src/examples/electrostatics.md:141
msgid "The refinement is performed using the selection `srefine` just created"
msgstr ""

#: src/examples/electrostatics.md:145
msgid ""
"which returns a Dictionary mapping the old quantities to the new refined "
"ones. We use this dictionary to update the OptimizationProblem and "
"FieldOptimizer,"
msgstr ""

#: src/examples/electrostatics.md:151
msgid "and finally update our variables"
msgstr ""

#: src/examples/electrostatics.md:159
msgid "Finally, we equiangulate the mesh to help avoid narrow elements,"
msgstr ""

#: src/examples/electrostatics.md:163
msgid ""
"Once refinement is complete, further optimization can occur on the newly "
"refined mesh"
msgstr ""

#: src/examples/electrostatics.md:168
msgid ""
"The process of refinement and optimization just described takes place in a "
"loop. The resulting mesh after 10 iterations is shown in Fig. [7.6](#fig:"
"Electrostatics), together with the solution \\\\(\\phi\\\\). The code runs "
"in a few seconds, providing a considerable speedup over optimizing on a fine "
"grid to get comparable accuracy."
msgstr ""

#: src/examples/implicitmesh.md:3
msgid ""
"These examples illustrate how to use the `implicitmesh` module to generate "
"surfaces described as the zero set of a scalar function. The `sphere.morpho` "
"and `torus.morpho` examples are described more fully in Chapter X, Section "
"Y. The remaining `threesurface.morpho` creates a triangulation of a surface "
"with three handles, $$r\\_{z}^{4}z^{2}-\\left(1-\\left(\\frac{x}"
"{r\\_{x}}\\right)^{2}-\\left(\\frac{y}{r\\_{y}}\\right)^{2}\\right)\\left((x-"
"x\\_{1})^{2}+y^{2}-r\\_{1}^{2}\\right)\\left((x+x\\_{1})^{2}+y^{2}-r\\_{1}"
"^{2}\\right)\\left(x^{2}+y^{2}-r\\_{1}^{2}\\right)=0,$$ where \\\\(r\\_{x}\\"
"\\), \\\\(r\\_{y}\\\\), \\\\(r\\_{z}\\\\), \\\\(r\\_{1}\\\\) and \\"
"\\(x\\_{1}\\\\) are parameters. The resulting surface is shown in Fig. [7.7]"
"(#fig:Threesurface)."
msgstr ""

#: src/examples/meshgen.md:3
msgid ""
"Examples in this folder illustrate various techniques to create Meshes with "
"the `meshgen` module. Examples in two dimensions are shown in Fig. [7.8]"
"(#fig:Meshgen-2D); those in 3D are shown in Fig. [7.9](#fig:Meshgen-3D). See "
"also the [Meshgen Section](../working_with_meshes/meshgen_module.md) of the "
"[Working with Meshes Chapter](../working_with_meshes.md) for additional "
"discussion of the `meshgen` module."
msgstr ""

#: src/examples/meshslice.md:13
msgid ""
"This example shows how to use the `meshslice` module to create a slice "
"through a mesh for visualization purposes. The program uses a spherical mesh,"
msgstr ""

#: src/examples/meshslice.md:17
msgid ""
"```\n"
"var m = Mesh(\"sphere.mesh\")\n"
"m.addgrade(1)\n"
"m.addgrade(2)\n"
"```"
msgstr ""

#: src/examples/meshslice.md:21
msgid "and creates a couple of example Fields, one scalar,"
msgstr ""

#: src/examples/meshslice.md:25
msgid "and one vector,"
msgstr ""

#: src/examples/meshslice.md:29
msgid "A MeshSlicer is created to do the slicing,"
msgstr ""

#: src/examples/meshslice.md:34
msgid "and then interpolated Fields along this slice are created too,"
msgstr ""

#: src/examples/meshslice.md:39
msgid ""
"Grade 1 elements (edges) from the original mesh, together with the field phi "
"interpolated onto three different slices, are shown in Fig. [7.10](#fig:"
"Meshslice). The example program illustrates a few other different "
"possibilities."
msgstr ""

#: src/examples/plot.md:3
msgid ""
"This example illustrates drawing of meshes, plotting of fields, etc. See the "
"[Visualization Chapter](../visualization.md) for more details."
msgstr ""

#: src/examples/povray.md:3
msgid ""
"Examples in this folder illustrates use of the `povray` module used to "
"produce publication quality renderings from within _morpho_ programs. All "
"figures in this book were generated using this module."
msgstr ""

#: src/examples/qtensor.md:1
msgid "Qtensor"
msgstr ""

#: src/examples/qtensor.md:16
msgid ""
"This example demonstrates use of the alternative Q-tensor formulation of "
"nematic liquid crystal theory. We briefly present the necessary theory in "
"two subsections below, then describe the implementation in _morpho_."
msgstr ""

#: src/examples/qtensor.md:20
msgid "The Q tensor"
msgstr ""

#: src/examples/qtensor.md:22
msgid ""
"In 2D, for a uniaxial nematic, we can define a Q-tensor: $$Q\\_{ij}=S(n\\_{i}"
"n\\_{j}-1/2\\delta\\_{ij})$$ Here, the \\\\(-1/2\\delta\\_{ij}\\\\) is added "
"for convenience, to make the matrix traceless: $$\\text{Tr}"
"(\\mathbf{Q})=Q\\_{ii}=S(n\\_{i}n\\_{i}-1/2\\delta\\_{ii})=S(1-1/2(2))=0$$ "
"Now, the Q-tensor is also symmetric by definition: $$Q\\_{ij}=Q\\_{ji}$$ Due "
"to these two reasons we can write the Q-tensor as a function of only \\"
"\\(Q\\_{xx}\\\\) and \\\\(Q\\_{xy}\\\\): "
msgstr ""

#: src/examples/qtensor.md:30
msgid ""
"$$ \\mathbf{Q}= \\\\begin{bmatrix} Q\\_{xx} & Q\\_{xy} \\\\\\\\ Q\\_{xy} & -"
"Q\\_{xx} \\\\end{bmatrix}. $$"
msgstr ""

#: src/examples/qtensor.md:37
msgid "Elastic Energy and Anchoring"
msgstr ""

#: src/examples/qtensor.md:39
msgid ""
"The Landau-de Gennes equilibrium free energy for a nematic liquid crystal "
"can be written in terms of the Q-tensor: "
msgstr ""

#: src/examples/qtensor.md:42
msgid ""
"$$ F\\_{LDG}= \\int\\_{\\Omega}d^{2}{\\bf x}\\ \\left(\\frac{a\\_{2}}"
"{2}\\text{Tr}(\\mathbf{Q}^{2})+\\frac{a\\_{4}}{4}(\\text{Tr}\\mathbf{Q}"
"^{2})^{2}+\\frac{K}{2}(\\nabla\\mathbf{Q})^{2}\\right) $$ $$ +"
"\\oint\\_{\\partial\\Omega}d{\\bf x}\\frac{1}{2}"
"E\\_{A}\\text{Tr}\\[(\\mathbf{Q}-\\mathbf{W})^{2}\\] $$ "
msgstr ""

#: src/examples/qtensor.md:46
msgid ""
"where \\\\(a\\_{2}=(\\rho-1)\\\\) and \\\\(a\\_{4}=(\\rho+1)/\\rho^{2}\\\\) "
"set the isotropic to nematic transition with \\\\(\\rho\\\\) being the non-"
"dimensional density. The system is in the isotropic state for \\"
"\\(\\rho\\<1\\\\) and in the nematic phase when \\\\(\\rho>1\\\\). In the "
"nematic phase, \\\\(\\ell\\_{n}=\\sqrt{K/a\\_{2}}\\\\) sets the nematic "
"coherence length. Now,"
msgstr ""

#: src/examples/qtensor.md:52
msgid ""
"$$\\mathbf{Q}^{2}=\\begin{bmatrix}Q\\_{xx} & Q\\_{xy} \\\\\\\\ Q\\_{xy} & -"
"Q\\_{xx} \\\\end{bmatrix}\\begin{bmatrix}Q\\_{xx} & Q\\_{xy} \\\\\\\\ "
"Q\\_{xy} & -Q\\_{xx} \\\\end{bmatrix}=(Q\\_{xx}^{2}+Q\\_{xy}"
"^{2})\\begin{bmatrix}1 & 0 \\\\\\\\ 0 & 1 \\\\end{bmatrix}$$ Hence, $$"
"\\text{Tr}(\\mathbf{Q}^{2})=2(Q\\_{xx}^{2}+Q\\_{xy}^{2})$$ Similarly, $"
"$(\\nabla\\mathbf{Q})^{2}=\\partial\\_{i}Q\\_{kj}\\partial\\_{i}Q\\_{kj}"
"=2{(\\partial\\_{x}Q\\_{xx})^{2}+(\\partial\\_{x}"
"Q\\_{xy})^{2}+(\\partial\\_{y}Q\\_{xx})^{2}+(\\partial\\_{y}Q\\_{xy})^{2}}$$ "
"Now, the second term is a boundary integral, with \\\\(E\\_{A}\\\\) being "
"the anchoring strength. \\\\(\\mathbf{W}\\\\) is the tensor corresponding to "
"the boundary condition. For instance, for parallel anchoring, $$W\\_{ij}"
"=(t\\_{i}t\\_{j}-1/2\\delta\\_{ij})$$ where \\\\(t\\_{i}\\\\) is a component "
"of the tangent vector at the boundary. \\\\(\\mathbf{W}\\\\) is also a "
"symmetric traceless tensor with two independent components \\\\(W\\_{xx}\\"
"\\) and \\\\(W\\_{xy}\\\\). The boundary term becomes: $$"
"\\text{Tr}\\[(\\mathbf{Q}-\\mathbf{W})^{2}\\]=2{Q\\_{xx}^{2}+Q\\_{xy}"
"^{2}-2(Q\\_{xx}W\\_{xx}+Q\\_{xy}W\\_{xy})+W\\_{xx}^{2}+W\\_{xy}^{2}}$$"
msgstr ""

#: src/examples/qtensor.md:70
msgid "Optimization problem"
msgstr ""

#: src/examples/qtensor.md:72
msgid ""
"We can formulate all the preceding expressions in terms of vector "
"quantities: $$\\vec{q}\\equiv \\\\{ Q\\_{xx},Q\\_{xy} \\\\} $$ $$"
"\\vec{w}\\equiv \\\\{w\\_{xx},w\\_{xy} \\\\}$$ Thus, $$\\text{Tr}(\\mathbf{Q}"
"^{2})=2||\\vec{q}||^{2}$$"
msgstr ""

#: src/examples/qtensor.md:77
msgid "$$(\\nabla\\mathbf{Q})^{2}=2||\\nabla\\vec{q}||^{2}$$"
msgstr ""

#: src/examples/qtensor.md:79
msgid ""
"$$\\text{Tr}\\[(\\mathbf{Q}-\\mathbf{W})^{2}\\]=2||\\vec{q}-\\vec{w}||^{2}$$ "
"With these, we want to minimize the area-integral of $$F=\\int\\_{\\Omega}"
"d^{2}{\\bf x}\\ \\left(a\\_{2}||\\vec{q}||^{2}+a\\_{4}||\\vec{q}||^{4}+K||"
"\\nabla\\vec{q}||^{2}\\right)$$ together with the line-integral energy $$"
"\\oint\\_{\\partial\\Omega}d{\\bf x}\\ E\\_{A}||\\vec{q}-\\vec{w}||^{2}$$"
msgstr ""

#: src/examples/qtensor.md:85
msgid "Implementation"
msgstr ""

#: src/examples/qtensor.md:87
msgid ""
"This free energy is readily set up in _morpho_. For this example, we "
"consider a 2D disk geometry with unit radius. We use \\\\(\\rho=1.3\\\\), so "
"that we are deep in the nematic regime. We fix \\\\(E\\_{\\text{A}}=3\\\\), "
"which sets strong anchoring at the boundary. With this strong tangential "
"anchoring, we get a topological charge of \\\\(+1\\\\) at the boundary, and "
"this acts as a constraint. When the nematic coherence length is comparable "
"to the disk diameter (\\\\(\\ell\\_{n}\\sim R\\\\)), the \\\\(+1\\\\) charge "
"penetrates throughout the disk, whereas if (\\\\(\\ell\\_{n}\\ll R\\\\)), "
"then a formation with 2 \\\\(+1/2\\\\) defects is more stable. To test this, "
"we use two different values of \\\\(K\\\\):, 0.01 and 1.0."
msgstr ""

#: src/examples/qtensor.md:98
msgid ""
"We first define all our parameters and import \\\\(\\texttt{disk.mesh}\\\\) "
"from the tactoid example:"
msgstr ""

#: src/examples/qtensor.md:101
msgid ""
"```\n"
"var rho = 1.3 // Deep in the nematic phase\n"
"var EA = 3 // Anchoring strength\n"
"var K = 0.01 // Bending modulus\n"
"\n"
"var a2 = (1-rho)\n"
"var a4 = (1+rho)/rho^2\n"
"\n"
"var m = Mesh(\"disk.mesh\")\n"
"var m = refinemesh(m) // Refining for a better result\n"
"var bnd = Selection(m, boundary=true)\n"
"bnd.addgrade(0) // add point elements\n"
"```"
msgstr ""

#: src/examples/qtensor.md:113
msgid ""
"We define the Q-tensor in its vector form as discussed above, initializing "
"it to small random values:"
msgstr ""

#: src/examples/qtensor.md:119
msgid ""
"Note that this incidentally makes the director parallel to a 45 degree line. "
"We now define the bulk energy, the anchoring energy and the distortion free "
"energy as follows:"
msgstr ""

#: src/examples/qtensor.md:123
msgid ""
"```\n"
"// Define bulk free energy\n"
"fn landau(x, q) {\n"
"  var qt = q.norm()\n"
"  var qt2=qt*qt\n"
"  return a2*qt2 + a4*qt2*qt2\n"
"}\n"
"// Define anchoring energy at the boundary\n"
"fn anchoring(x, q) {\n"
"  var t = tangent()\n"
"  var wxx = t[0]*t[0]-0.5\n"
"  var wxy = t[0]*t[1]\n"
"  return (q[0]-wxx)^2+(q[1]-wxy)^2\n"
"}\n"
"\n"
"var bulk = AreaIntegral(landau, q_tensor)\n"
"var anchor = LineIntegral(anchoring, q_tensor)\n"
"var elastic = GradSq(q_tensor)\n"
"```"
msgstr ""

#: src/examples/qtensor.md:141
msgid "Equipped with the energies, we define the `OptimizationProblem`:"
msgstr ""

#: src/examples/qtensor.md:148
msgid ""
"To minimize the energy with respect to the field, we define the "
"`FieldOptimizer` and perform a `linesearch`:"
msgstr ""

#: src/examples/qtensor.md:156
msgid ""
"For visualizing the final configuration, we use the same piece of code we "
"used for the tactoid example, and define some additional helper functions to "
"extract the director and the order from the Q-tensor:"
msgstr ""

#: src/examples/qtensor.md:174
msgid "We use these to create Fields from `q_tensor`."
msgstr ""

#: src/examples/qtensor.md:176
msgid ""
"```\n"
"// Convert the q-tensor to the director and order\n"
"var nn = Field(m, Matrix([1,0,0]))\n"
"for (i in 0...m.count()) nn[i]=qtodirector(q_tensor[i])\n"
"var S = Field(m, 0)\n"
"for (i in 0...m.count()) S[i]=qtoorder(q_tensor[i])\n"
"```"
msgstr ""

#: src/examples/qtensor.md:182
msgid ""
"and display these, reusing the `visualize` function from the tactoid "
"tutorial example."
msgstr ""

#: src/examples/qtensor.md:185
msgid ""
"```\n"
"var splot = plotfield(S, style=\"interpolate\")\n"
"var gnn=visualize(m, nn, 0.05)\n"
"var gdisp = splot+gnn\n"
"Show(gdisp)\n"
"```"
msgstr ""

#: src/examples/qtensor.md:190
msgid ""
"This creates beautiful plots of the nematic, displayed in Fig. [7.11](#fig:"
"Qtensor). Like the tactoid example, we can do adaptive mesh refinement based "
"on the elastic energy density as well."
msgstr ""

#: src/examples/thomson.md:13
msgid ""
"Consider \\\\(N\\\\) charges \\\\(q\\\\) with positions \\\\(x_i\\\\) that "
"are each confined to lie on the unit sphere so that \\\\(\\left| x_i\\right|"
"=1 \\\\) that repel each other electrostatically and hence whose "
"configuration minimizes the energy, $$\\frac{k}{2}\\sum\\_{i\\neq "
"j}\\frac{q^{2}}{\\left|x\\_{i}-x\\_{j}\\right|}$$ The problem was posed by "
"the physicist J. J. Thomson in 1904, in the context of an early model for "
"the structure of an atom."
msgstr ""

#: src/examples/thomson.md:21
msgid ""
"To set this up in _morpho_, we begin by creating a mesh from a sequence of "
"random points using a MeshBuilder object from the `meshtools` module. Notice "
"that this is quite an unusual mesh; it consists of \\\\(N\\\\) unconnected "
"points with no connectivity information."
msgstr ""

#: src/examples/thomson.md:26
msgid ""
"```\n"
"var build = MeshBuilder()\n"
"for (i in 1..Np) {\n"
"  var x = Matrix([2*random()-1, 2*random()-1, 2*random()-1])\n"
"  x/=x.norm() // Project onto unit sphere\n"
"  build.addvertex(x)\n"
"}\n"
"var mesh = build.build()\n"
"```"
msgstr ""

#: src/examples/thomson.md:34
msgid ""
"The optimization problem is then specified. We use the PairwisePotential "
"functional from the `functionals` module and supply the Coulomb potential \\"
"\\(1/r\\\\), together with its derivative \\\\(-1/r^{2}\\\\) as anonymous "
"functions:"
msgstr ""

#: src/examples/thomson.md:43
msgid ""
"Constraining the particles to a sphere is implemented as a level set "
"constraint: We use the ScalarPotential functional as a local constraint to "
"ensure that each particle lies on the zero contour of the scalar function \\"
"\\(x^{2}+y^{2}+z^{2}-1\\\\), which defines the unit sphere."
msgstr ""

#: src/examples/thomson.md:50
msgid "Optimization is then performed:"
msgstr ""

#: src/examples/thomson.md:57
msgid ""
"Notice that we estimate the initial stepsize from the number of particles. "
"Since each particle will adopt a fraction \\\\(1/N\\\\) of the area, the "
"stepsize is \\\\(\\propto1/\\sqrt{N}\\\\). In practice, we find that taking "
"a few steps of gradient descent with relax helps condition the problem by "
"pushing any particles from the initially random distribution that happened "
"to be placed very close to one another apart. After this "
"`conjugategradient`works well and typically converges in around \\\\(100\\"
"\\) iterations."
msgstr ""

#: src/examples/thomson.md:66
msgid ""
"A final interesting feature of this example is the use of a custom "
"visualization. We draw a sphere with a center of mass at the location at "
"each particle:"
msgstr ""

#: src/examples/thomson.md:77
msgid ""
"A typical configuration resulting from this is shown in Fig. [7.12](#fig:"
"Thomson). Note that we made the large sphere transparent to render with the "
"povray module; this was achieved by adding the optional argument "
"`transmit=0.3` to the call to `Sphere`."
msgstr ""

#: src/examples/wrap.md:12
msgid ""
"The wrap example finds a minimal surface constrainted to lie outside two "
"ellipsoids. The solution, shown in Fig. [7.13](#fig:Wrap) could represent, "
"for example, a possible configuration for a fluid bridge connecting two "
"ellipsoidal particles."
msgstr ""

#: src/examples/wrap.md:18
msgid ""
"The basic idea of this code is to \"shrink wrap\" the ellipsoids, starting "
"with an initial mesh is a cube that completely encloses them. This is "
"created with PolyhedronMesh from the `meshtools` module:"
msgstr ""

#: src/examples/wrap.md:22
msgid ""
"```\n"
"// Create a initial cube\n"
"var L = 2\n"
"var cube = [[-L, -L, -L], [-L, -L, L], [-L, L, -L],\n"
"            [-L, L, L], [L, -L, -L], [L, -L, L],\n"
"            [L, L, -L], [L, L, L]]\n"
"\n"
"var faces = [[7, 3, 1, 5], [7, 5, 4, 6], [7, 6, 2, 3], [3, 2, 0, 1], [0, 2, "
"6,   4], [1, 0, 4, 5]]\n"
"\n"
"var m=PolyhedronMesh(cube, faces)\n"
"m=refinemesh(m)\n"
"```"
msgstr ""

#: src/examples/wrap.md:33
msgid ""
"The particles are implemented as level set constraints. A convenient "
"Ellipsoid class is defined to help create appropriate constraints,"
msgstr ""

#: src/examples/wrap.md:36
msgid ""
"```\n"
"class Ellipsoid { // Construct with Ellipsoid(origin, principalradii)\n"
"  init(x, r) { \n"
"    self.origin = x\n"
"    self.principalradii = r\n"
"  }\n"
"  // Returns a level set function for this Ellipsoid\n"
"  levelset() {\n"
"    fn phi (x,y,z) {\n"
"      var x0 = self.origin, rr = self.principalradii\n"
"      return ((x-x0[0])/rr[0])^2 + ((y-x0[1])/rr[1])^2 + ((z-x0[2])/rr[2])^2 "
"- 1     \n"
"    }\n"
"    return phi\n"
"  }\n"
"  /* Analogous code for gradient() ... */\n"
"}\n"
"```"
msgstr ""

#: src/examples/wrap.md:52
msgid ""
"The `levelset` method manufactures a scalar function representing the "
"ellipsoid and suitable for use with the ScalarPotential functional. A second "
"method, `gradient`, returns the gradient of that function."
msgstr ""

#: src/examples/wrap.md:56
msgid "The two ellipsoids of interest are then created like so:"
msgstr ""

#: src/examples/wrap.md:61
msgid ""
"The optimization problem is set up to include the surface area subject to "
"satisfaction of the level set constraints; these are noted as one-sided, i."
"e. satisfied if the mesh lies at any point outside the constraint region."
msgstr ""

#: src/examples/wrap.md:66
msgid ""
"```\n"
"// We want to minimize the area\n"
"var la = Area() // Subject to level set constraints\n"
"var ls1 = ScalarPotential( ell1.levelset(), ell1.gradient() )\n"
"var ls2 = ScalarPotential( ell2.levelset(), ell2.gradient() )\n"
"var leq = EquiElement()\n"
"\n"
"var problem = OptimizationProblem(m)\n"
"problem.addenergy(la)\n"
"problem.addlocalconstraint(ls1, onesided=true)\n"
"problem.addlocalconstraint(ls2, onesided=true) \n"
"```"
msgstr ""

#: src/examples/wrap.md:77
msgid "To promote mesh quality, a second regularization problem is set up:"
msgstr ""

#: src/examples/wrap.md:84
msgid "Optimization and refinement are performed iteratively:"
msgstr ""

#: src/examples/wrap.md:102
msgid ""
"Note that we set `stepsize` and `steplimit` on each optimizer; these values "
"were found by trial and error. The initial shape is quite extreme, and so we "
"use `relax` for the main optimization problem which is very robust. Calling "
"`equiangulate` helps maintain mesh quality."
msgstr ""

#: src/reference.md:3
msgid ""
"This chapter mirrors the documentation of everything shipped with the core "
"Morpho distribution. The documentation is organized in the following "
"sections:"
msgstr ""

#: src/reference.md:5
msgid ""
"The [Language](reference/language.md) section provides a detailed "
"description of the Morpho language, including the syntax and semantics of "
"the language."
msgstr ""

#: src/reference.md:7
msgid ""
"The [Data Types](reference/data_types.md) section describes the various data "
"types like `List`'s, `Matrix` objects, etc."
msgstr ""

#: src/reference.md:9
msgid ""
"The [Computational Geometry](reference/computational_geometry.md) section "
"provides the documentation for meshes, selections, fields and functionals."
msgstr ""

#: src/reference.md:11
msgid ""
"The [I/O](reference/io.md) section provides the documentation for the `File` "
"object."
msgstr ""

#: src/reference.md:13
msgid ""
"The [Modules](reference/modules.md) section provides the documentation for "
"the various standard modules shipped with Morpho."
msgstr ""

#: src/reference/language.md:3
msgid ""
"This section provides a detailed description of the Morpho language, "
"including the syntax and semantics of the language."
msgstr ""

#: src/reference/nested/syntax.md:9
msgid ""
"Morpho provides a flexible object oriented language similar to other "
"languages in the C family (like C++, Java and Javascript) with a simplified "
"syntax."
msgstr ""

#: src/reference/nested/syntax.md:11
msgid ""
"Morpho programs are stored as plain text with the .morpho file extension. A "
"program can be run from the command line by typing"
msgstr ""

#: src/reference/nested/syntax.md:17
msgid "Comments"
msgstr ""

#: src/reference/nested/syntax.md:23
msgid ""
"Two types of comment are available. The first type is called a 'line "
"comment' whereby text after `//` on the same line is ignored by the "
"interpreter."
msgstr ""

#: src/reference/nested/syntax.md:26
msgid "// A comment\n"
msgstr ""

#: src/reference/nested/syntax.md:29
msgid ""
"Longer 'block' comments can be created by placing text between `/*` and `*/"
"`. Newlines are ignored"
msgstr ""

#: src/reference/nested/syntax.md:32
msgid ""
"/* This\n"
"   is\n"
"   a longer comment */"
msgstr ""

#: src/reference/nested/syntax.md:37
msgid "In contrast to C, these comments can be nested"
msgstr ""

#: src/reference/nested/syntax.md:40
msgid "/* A nested /* comment */"
msgstr ""

#: src/reference/nested/syntax.md:40
msgid "/\n"
msgstr ""

#: src/reference/nested/syntax.md:43
msgid "enabling the programmer to quickly comment out a section of code."
msgstr ""

#: src/reference/nested/syntax.md:45
msgid "Symbols"
msgstr ""

#: src/reference/nested/syntax.md:49
msgid ""
"Symbols are used to refer to named entities, including variables, classes, "
"functions etc. Symbols must begin with a letter or underscore _ as the first "
"character and may include letters or numbers as the remainder. Symbols are "
"case sensitive."
msgstr ""

#: src/reference/nested/syntax.md:59
msgid ""
"Classes are typically given names with an initial capital letter. Variable "
"names are usually all lower case."
msgstr ""

#: src/reference/nested/syntax.md:61
msgid "Newlines"
msgstr ""

#: src/reference/nested/syntax.md:65
msgid ""
"Strictly, morpho ends statements with semicolons like C, but in practice "
"these are usually optional and you can just start a new line instead. For "
"example, instead of"
msgstr ""

#: src/reference/nested/syntax.md:68
msgid "// The ; is optional\n"
msgstr ""

#: src/reference/nested/syntax.md:71
msgid "you can simply use"
msgstr ""

#: src/reference/nested/syntax.md:77
msgid ""
"If you want to put several statements on the same line, you can separate "
"them with semicolons:"
msgstr ""

#: src/reference/nested/syntax.md:83
msgid ""
"There are a few edge cases to be aware of: The morpho parser works by "
"accepting a newline anywhere it expects to find a semicolon. To split a "
"statement over multiple lines, signal to morpho that you plan to continue by "
"leaving the statement unfinished. Hence, do this:"
msgstr ""

#: src/reference/nested/syntax.md:90
msgid "rather than this:"
msgstr ""

#: src/reference/nested/syntax.md:93
msgid "// < Morpho thinks this is a complete statement\n"
msgstr ""

#: src/reference/nested/syntax.md:94
msgid "// < and so this line will cause a syntax error\n"
msgstr ""

#: src/reference/nested/syntax.md:98
msgid "Booleans"
msgstr ""

#: src/reference/nested/syntax.md:103
msgid ""
"Comparison operations like `==`, `<` and `>=` return `true` or `false` "
"depending on the result of the comparison. For example,"
msgstr ""

#: src/reference/nested/syntax.md:109
msgid ""
"prints `false`. The constants `true` or `false` are provided for you to use "
"in your own code:"
msgstr ""

#: src/reference/nested/syntax.md:115
msgid "Nil"
msgstr ""

#: src/reference/nested/syntax.md:118
msgid ""
"The keyword `nil` is used to represent the absence of an object or value."
msgstr ""

#: src/reference/nested/syntax.md:120
msgid "Note that in `if` statements, a value of `nil` is treated like `false`."
msgstr ""

#: src/reference/nested/syntax.md:124
msgid "// Never executed.\n"
msgstr ""

#: src/reference/nested/syntax.md:128
msgid "Blocks"
msgstr ""

#: src/reference/nested/syntax.md:132
msgid ""
"Code is divided into _blocks_, which are delimited by curly brackets like "
"this:"
msgstr ""

#: src/reference/nested/syntax.md:136 src/reference/nested/syntax.md:182
#: src/reference/nested/variables.md:25 src/reference/nested/controlflow.md:185
#: src/reference/nested/errors.md:52 src/reference/nested/list.md:28
#: src/reference/nested/string.md:18
msgid "\"Hello\""
msgstr ""

#: src/reference/nested/syntax.md:141
msgid ""
"This syntax is used in function declarations, loops and conditional "
"statements."
msgstr ""

#: src/reference/nested/syntax.md:143
msgid ""
"Any variables declared within a block become _local_ to that block, and "
"cannot be seen outside of it. For example,"
msgstr ""

#: src/reference/nested/syntax.md:146 src/reference/nested/classes.md:125
#: src/reference/nested/list.md:52 src/reference/nested/list.md:62
msgid "\"Foo\""
msgstr ""

#: src/reference/nested/syntax.md:148
msgid "\"Bar\""
msgstr ""

#: src/reference/nested/syntax.md:154
msgid ""
"would print \"Bar\" then \"Foo\"; the version of `a` inside the code block "
"is said to _shadow_ the outer version."
msgstr ""

#: src/reference/nested/syntax.md:156
msgid "Precedence"
msgstr ""

#: src/reference/nested/syntax.md:159
msgid ""
"Precedence refers to the order in which morpho evaluates operations. For "
"example,"
msgstr ""

#: src/reference/nested/syntax.md:165
msgid ""
"prints `7` because `2*3` is evaluated before the addition; the operator `*` "
"is said to have higher precedence than `+`."
msgstr ""

#: src/reference/nested/syntax.md:167
msgid "You can always modify the order of evaluation by using parentheses:"
msgstr ""

#: src/reference/nested/syntax.md:170
msgid "// prints 9\n"
msgstr ""

#: src/reference/nested/syntax.md:173
msgid "Print"
msgstr ""

#: src/reference/nested/syntax.md:176
msgid ""
"The `print` keyword is used to print information to the console. It can be "
"followed by any value, e.g."
msgstr ""

#: src/reference/nested/values.md:7
msgid ""
"Values are the basic unit of information in morpho: All functions in morpho "
"accept values as arguments and return values. "
msgstr ""

#: src/reference/nested/values.md:11
msgid "Int"
msgstr ""

#: src/reference/nested/values.md:14
msgid ""
"Morpho provides integers, which work as you would expect in other languages, "
"although you rarely need to worry about the distinction between floats and "
"integers. "
msgstr ""

#: src/reference/nested/values.md:16
msgid "Convert a floating point number to an Integer: "
msgstr ""

#: src/reference/nested/values.md:19 src/reference/nested/values.md:54
#: src/reference/nested/builtin.md:196 src/reference/nested/builtin.md:243
#: src/reference/nested/builtin.md:270 src/reference/nested/builtin.md:279
msgid "// expect: 1\n"
msgstr ""

#: src/reference/nested/values.md:22
msgid "Convert a string to an integer:"
msgstr ""

#: src/reference/nested/values.md:25
msgid "\"10\""
msgstr ""

#: src/reference/nested/values.md:25
msgid "// expect: 11\n"
msgstr ""

#: src/reference/nested/values.md:28
msgid "Float"
msgstr ""

#: src/reference/nested/values.md:31
msgid "Morpho provides double precision floating point numbers. "
msgstr ""

#: src/reference/nested/values.md:33
msgid "Convert a string to a floating point number:"
msgstr ""

#: src/reference/nested/values.md:36
msgid "\"1.2e2\""
msgstr ""

#: src/reference/nested/values.md:36
msgid "// expect: 121\n"
msgstr ""

#: src/reference/nested/values.md:39
msgid "Ceil"
msgstr ""

#: src/reference/nested/values.md:42
msgid "Returns the smallest integer larger than or equal to its argument:"
msgstr ""

#: src/reference/nested/values.md:45 src/reference/nested/functions.md:106
#: src/reference/nested/builtin.md:324
msgid "// expect: 2\n"
msgstr ""

#: src/reference/nested/values.md:48
msgid "Floor"
msgstr ""

#: src/reference/nested/values.md:51
msgid "Returns the largest integer smaller than or equal to its argument:"
msgstr ""

#: src/reference/nested/values.md:57
msgid "Format"
msgstr ""

#: src/reference/nested/values.md:60
msgid ""
"The format method converts a number to a `String` using a given format "
"specifier: "
msgstr ""

#: src/reference/nested/values.md:63
msgid "\"%4.2g\""
msgstr ""

#: src/reference/nested/values.md:63
msgid "// Outputs 0.33\n"
msgstr ""

#: src/reference/nested/values.md:66
msgid "The specifier must begin with '%' and may include: "
msgstr ""

#: src/reference/nested/values.md:68
msgid "A minimum width, given as an integer. "
msgstr ""

#: src/reference/nested/values.md:69
msgid "Number of decimal places to show, with '.' in front."
msgstr ""

#: src/reference/nested/values.md:70
msgid "A formatting option, either 'f' or 'g' where:"
msgstr ""

#: src/reference/nested/values.md:72
msgid "'f'"
msgstr ""

#: src/reference/nested/values.md:73
msgid "'g'"
msgstr ""

#: src/reference/nested/values.md:76
msgid ""
"The syntax for the formatting string is similar to that used in C and Python."
msgstr ""

#: src/reference/nested/variables.md:10
msgid ""
"Variables are defined using the `var` keyword followed by the variable name:"
msgstr ""

#: src/reference/nested/variables.md:16
msgid "Optionally, an initial assignment may be given:"
msgstr ""

#: src/reference/nested/variables.md:22
msgid ""
"Variables defined in a block of code are visible only within that block, so"
msgstr ""

#: src/reference/nested/variables.md:27
msgid "\"Goodbye\""
msgstr ""

#: src/reference/nested/variables.md:33
msgid "will print"
msgstr ""

#: src/reference/nested/variables.md:35
msgid "_Goodbye_ _Hello_"
msgstr ""

#: src/reference/nested/variables.md:38
msgid ""
"Multiple variables can be defined at once by separating them with commas"
msgstr ""

#: src/reference/nested/variables.md:44
msgid "where each can have its own initializer (or not)."
msgstr ""

#: src/reference/nested/variables.md:46
msgid "Indexing"
msgstr ""

#: src/reference/nested/variables.md:52
msgid ""
"Morpho provides a number of collection objects, such as `List`, `Range`, "
"`Array`, `Dictionary`, `Matrix` and `Sparse`, that can contain more than one "
"value. Index notation (sometimes called subscript notation) is used to "
"access elements of these objects."
msgstr ""

#: src/reference/nested/variables.md:54
msgid ""
"To retrieve an item from a collection, you use the `[` and `]` brackets like "
"this:"
msgstr ""

#: src/reference/nested/variables.md:57
msgid "\"Apple\""
msgstr ""

#: src/reference/nested/variables.md:57
msgid "\"Bag\""
msgstr ""

#: src/reference/nested/variables.md:57
msgid "\"Cat\""
msgstr ""

#: src/reference/nested/variables.md:61
msgid ""
"which prints _Apple_. Note that the first element is accessed with `0` not "
"`1`."
msgstr ""

#: src/reference/nested/variables.md:63
msgid "Similarly, to set an entry in a collection, use:"
msgstr ""

#: src/reference/nested/variables.md:66
msgid "\"Adder\""
msgstr ""

#: src/reference/nested/variables.md:69
msgid "which would replaces the first element in `a` with `\"Adder\"`."
msgstr ""

#: src/reference/nested/variables.md:71
msgid "Some collection objects need more than one index,"
msgstr ""

#: src/reference/nested/variables.md:78
msgid "and others such as `Dictionary` use non-numerical indices,"
msgstr ""

#: src/reference/nested/variables.md:82
msgid "\"Massachusetts\""
msgstr ""

#: src/reference/nested/variables.md:82
msgid "\"Boston\""
msgstr ""

#: src/reference/nested/variables.md:83
msgid "\"California\""
msgstr ""

#: src/reference/nested/variables.md:83
msgid "\"Sacramento\""
msgstr ""

#: src/reference/nested/variables.md:86
msgid "as in this dictionary of state capitals."
msgstr ""

#: src/reference/nested/controlflow.md:9
msgid ""
"Control flow statements are used to determine whether and how many times a "
"selected piece of code is executed. These include:"
msgstr ""

#: src/reference/nested/controlflow.md:11
msgid "`if` - Selectively execute a piece of code if a condition is met."
msgstr ""

#: src/reference/nested/controlflow.md:12
msgid ""
"`else` - Execute a different block of code if the test in an `if` statement "
"fails."
msgstr ""

#: src/reference/nested/controlflow.md:13
msgid "`for` - Repeatedly execute a section of code with a counter"
msgstr ""

#: src/reference/nested/controlflow.md:14
msgid ""
"`while` - Repeatedly execute a section of code while a condition is true."
msgstr ""

#: src/reference/nested/controlflow.md:16
msgid "If"
msgstr ""

#: src/reference/nested/controlflow.md:20
msgid ""
"`If` allows you to selectively execute a section of code depending on "
"whether a condition is met. The simplest version looks like this:"
msgstr ""

#: src/reference/nested/controlflow.md:26
msgid ""
"where the body of the loop, `print x`, is only executed if x is less than 1. "
"The body can be a code block to accommodate longer sections of code:"
msgstr ""

#: src/reference/nested/controlflow.md:30
#: src/reference/nested/controlflow.md:38
msgid "// do something\n"
msgstr ""

#: src/reference/nested/controlflow.md:34
msgid "If you want to choose between two alternatives, use `else`:"
msgstr ""

#: src/reference/nested/controlflow.md:40
msgid "// this code is executed only if the condition is false\n"
msgstr ""

#: src/reference/nested/controlflow.md:44
msgid "You can even chain multiple tests together like this:"
msgstr ""

#: src/reference/nested/controlflow.md:48
msgid "// option 1\n"
msgstr ""

#: src/reference/nested/controlflow.md:50
msgid "// option 2\n"
msgstr ""

#: src/reference/nested/controlflow.md:52
msgid "// something else\n"
msgstr ""

#: src/reference/nested/controlflow.md:56
msgid "While"
msgstr ""

#: src/reference/nested/controlflow.md:59
msgid ""
"While loops repeat a section of code while a condition is true. For example,"
msgstr ""

#: src/reference/nested/controlflow.md:67
msgid ""
"prints the numbers 1 to 4. The loop has two sections: `cond` is the "
"condition to be executed and `body` is the section of code to be repeated."
msgstr ""

#: src/reference/nested/controlflow.md:69
msgid ""
"Simple loops like the above example, especially those that involve counting "
"out a sequence of numbers, are more conveniently written using a `for` loop,"
msgstr ""

#: src/reference/nested/controlflow.md:75
msgid ""
"Where `while` loops can be very useful is where the state of an object is "
"being changed in the loop, e.g."
msgstr ""

#: src/reference/nested/controlflow.md:82
msgid "which prints 4,3,2,1."
msgstr ""

#: src/reference/nested/controlflow.md:84
msgid "Do"
msgstr ""

#: src/reference/nested/controlflow.md:87
msgid ""
"A `do`...`while` loop repeats code while a condition is true---similar to a "
"`while` loop---but the test happens at the end:"
msgstr ""

#: src/reference/nested/controlflow.md:97
msgid "which prints 1,2,3,4"
msgstr ""

#: src/reference/nested/controlflow.md:99
msgid "Hence this type of loop executes at least one interation"
msgstr ""

#: src/reference/nested/controlflow.md:101
msgid "For"
msgstr ""

#: src/reference/nested/controlflow.md:105
msgid ""
"For loops allow you to repeatedly execute a section of code. They come in "
"two versions: the simpler version looks like this,"
msgstr ""

#: src/reference/nested/controlflow.md:111
msgid ""
"which prints the numbers 1 to 5 in turn. The variable `i` is the _loop "
"variable_, which takes on a different value each iteration. `1..5` is a "
"range, which denotes a sequence of numbers. The _body_ of the loop,  `print "
"i`, is the code to be repeatedly executed."
msgstr ""

#: src/reference/nested/controlflow.md:113
msgid ""
"Morpho will implicitly insert a `var` before the loop variable if it's "
"missing, so this works too:"
msgstr ""

#: src/reference/nested/controlflow.md:119
msgid ""
"If you want your loop variable to count in increments other than 1, you can "
"specify a stepsize in the range:"
msgstr ""

#: src/reference/nested/controlflow.md:126
msgid "Ranges need not be integer:"
msgstr ""

#: src/reference/nested/controlflow.md:132
msgid ""
"You can also replace the range with other kinds of collection object to loop "
"over their contents:"
msgstr ""

#: src/reference/nested/controlflow.md:139
msgid ""
"Morpho iterates over the collection object using an integer _counter "
"variable_ that's normally hidden. If you want to know the current value of "
"the counter (e.g. to get the index of an element as well as its value), you "
"can use the following:"
msgstr ""

#: src/reference/nested/controlflow.md:143
msgid "\"${i}: ${x}\""
msgstr ""

#: src/reference/nested/controlflow.md:146
msgid "Morpho also provides a second form of `for` loop similar to that in C:"
msgstr ""

#: src/reference/nested/controlflow.md:153
msgid ""
"which is executed as follows: start: the variable `i` is declared and "
"initially set to zero. test: before each iteration, the test is evaluated. "
"If the test is `false`, the loop terminates. body: the body of the loop is "
"executed. inc: the variable `i` is increased by 1."
msgstr ""

#: src/reference/nested/controlflow.md:159
msgid "You can include any code that you like in each of the sections."
msgstr ""

#: src/reference/nested/controlflow.md:161
msgid "Break"
msgstr ""

#: src/reference/nested/controlflow.md:164
msgid "`Break` is used inside loops to finish the loop early. For example"
msgstr ""

#: src/reference/nested/controlflow.md:168
msgid "// --.\n"
msgstr ""

#: src/reference/nested/controlflow.md:169
msgid "//   | (Once i>3)\n"
msgstr ""

#: src/reference/nested/controlflow.md:170
msgid "//   |\n"
msgstr ""

#: src/reference/nested/controlflow.md:171
msgid "// <-'\n"
msgstr ""

#: src/reference/nested/controlflow.md:174
msgid ""
"would only print 1, 2 and 3. Once the condition `i>3` is true, the `break` "
"statement causes execution to continue after the loop body."
msgstr ""

#: src/reference/nested/controlflow.md:176
msgid "Both `for` and `while` loops support break."
msgstr ""

#: src/reference/nested/controlflow.md:178
msgid "Continue"
msgstr ""

#: src/reference/nested/controlflow.md:181
msgid ""
"`Continue` is used inside loops to skip over the rest of an iteration. For "
"example"
msgstr ""

#: src/reference/nested/controlflow.md:184
msgid "// <-.\n"
msgstr ""

#: src/reference/nested/controlflow.md:186
msgid "// --'\n"
msgstr ""

#: src/reference/nested/controlflow.md:191
msgid ""
"prints \"Hello\" five times but only prints 1, 2 and 3. Once the condition "
"`i>3` is true, the `continue` statement causes execution to transfer to the "
"start of the loop body."
msgstr ""

#: src/reference/nested/controlflow.md:193
msgid "Traditional `for` loops also support `continue`:"
msgstr ""

#: src/reference/nested/controlflow.md:196
msgid "// v increment\n"
msgstr ""

#: src/reference/nested/controlflow.md:203
msgid ""
"Since `continue` causes control to be transferred _to the increment section_ "
"in this kind of loop, here the program prints 0..4 but the number 2 is "
"skipped."
msgstr ""

#: src/reference/nested/controlflow.md:205
msgid ""
"Use of `continue` with `while` loops is possible but isn't recommended as it "
"can easily produce an infinite loop!"
msgstr ""

#: src/reference/nested/controlflow.md:216
msgid ""
"In this example, when the condition `i==2` is `true`, execution skips back "
"to the start, but `i` _isn't_ incremented. The loop gets stuck in the "
"iteration `i==2`."
msgstr ""

#: src/reference/nested/controlflow.md:218
msgid "Try"
msgstr ""

#: src/reference/nested/controlflow.md:222
msgid "A `try` and `catch` statement allow you handle errors. For example"
msgstr ""

#: src/reference/nested/controlflow.md:226
msgid "// Do something\n"
msgstr ""

#: src/reference/nested/controlflow.md:228 src/reference/nested/errors.md:13
msgid "\"Tag\""
msgstr ""

#: src/reference/nested/controlflow.md:228
msgid "// Handle the error\n"
msgstr ""

#: src/reference/nested/controlflow.md:232
msgid ""
"Code within the block after the `try` keyword is executed. If an error is "
"generated then Morpho looks to see if the tag associated with the error "
"matches any of the labels in the `catch` block. If it does, the code after "
"the matching label is executed. If no error occurs, the catch block is "
"skipped entirely."
msgstr ""

#: src/reference/nested/functions.md:11
msgid ""
"A function in morpho is defined with the `fn` keyword, followed by the "
"function's name, a list of parameters enclosed in parentheses, and the body "
"of the function in curly braces. This example computes the square of a "
"number:"
msgstr ""

#: src/reference/nested/functions.md:19
msgid ""
"Once a function has been defined you can evaluate it like any other morpho "
"function."
msgstr ""

#: src/reference/nested/functions.md:27
msgid "Variadic"
msgstr ""

#: src/reference/nested/functions.md:30
msgid ""
"As well as regular parameters, functions can also be defined with _variadic_ "
"parameters: "
msgstr ""

#: src/reference/nested/functions.md:38
msgid "This function can then be called with 1 or more arguments: "
msgstr ""

#: src/reference/nested/functions.md:43
msgid "// All valid! \n"
msgstr ""

#: src/reference/nested/functions.md:46
msgid ""
"The variadic parameter `v` captures all the extra arguments supplied. "
"Functions cannot be defined with more than one variadic parameter. "
msgstr ""

#: src/reference/nested/functions.md:48
msgid ""
"You can mix regular, variadic and optional parameters. Variadic parameters "
"come before optional parameters:"
msgstr ""

#: src/reference/nested/functions.md:52
msgid "// \n"
msgstr ""

#: src/reference/nested/functions.md:56
msgid "Optional"
msgstr ""

#: src/reference/nested/functions.md:59
msgid "Functions can also be defined with _optional_ parameters:"
msgstr ""

#: src/reference/nested/functions.md:67
msgid ""
"Each optional parameter must be defined with a default value (here `1`). The "
"function can then be called either with or without the optional parameter: "
msgstr ""

#: src/reference/nested/functions.md:70
msgid "// a == 1 due to default value\n"
msgstr ""

#: src/reference/nested/functions.md:71
msgid "// a == 2 supplied by the user\n"
msgstr ""

#: src/reference/nested/functions.md:74
msgid "Return"
msgstr ""

#: src/reference/nested/functions.md:77
msgid ""
"The `return` keyword is used to exit from a function, optionally passing a "
"given value back to the caller. `return` can be used anywhere within a "
"function. The below example calculates the `n` th Fibonacci number,"
msgstr ""

#: src/reference/nested/functions.md:86
msgid ""
"by returning early if `n<2`, otherwise returning the result by recursively "
"calling itself."
msgstr ""

#: src/reference/nested/functions.md:88
msgid "Closures"
msgstr ""

#: src/reference/nested/functions.md:92
msgid ""
"Functions in morpho can form _closures_, i.e. they can enclose information "
"from their local context. In this example, "
msgstr ""

#: src/reference/nested/functions.md:101
msgid ""
"the function `foo` returns a function that captures the value of `a`. If we "
"now try calling `foo` and then calling the returned functions,"
msgstr ""

#: src/reference/nested/functions.md:105 src/reference/nested/builtin.md:224
#: src/reference/nested/builtin.md:333 src/reference/nested/builtin.md:334
msgid "// expect: 1 \n"
msgstr ""

#: src/reference/nested/functions.md:109
msgid ""
"we can see that `p` and `q` seem to contain different copies of `g` that "
"encapsulate the value that `foo` was called with. "
msgstr ""

#: src/reference/nested/functions.md:111
msgid ""
"Morpho hints that a returned function is actually a closure by displaying it "
"with double brackets: "
msgstr ""

#: src/reference/nested/functions.md:114
msgid "// expect: <<fn g>> \n"
msgstr ""

#: src/reference/nested/classes.md:10
msgid ""
"Classes are defined using the `class` keyword followed by the name of the "
"class. The definition includes methods that the class responds to. The "
"special `init` method is called whenever an object is created."
msgstr ""

#: src/reference/nested/classes.md:23
msgid "\"A delicious \""
msgstr ""

#: src/reference/nested/classes.md:23
msgid "\" cake\""
msgstr ""

#: src/reference/nested/classes.md:28
msgid "Objects are created by calling the class as if it was a function:"
msgstr ""

#: src/reference/nested/classes.md:31
msgid "\"carrot\""
msgstr ""

#: src/reference/nested/classes.md:34
msgid ""
"Note that all objects in Morpho inherit from a base `Object` class, which "
"provides a set of standard methods."
msgstr ""

#: src/reference/nested/classes.md:36
msgid "See also `Object`."
msgstr ""

#: src/reference/nested/classes.md:40
msgid "Is"
msgstr ""

#: src/reference/nested/classes.md:43
msgid "The `is` keyword is used to specify a class's superclass:"
msgstr ""

#: src/reference/nested/classes.md:53
msgid ""
"All methods defined by the superclass `B` are copied into the new class `A`, "
"_before_ any methods specified in the class definition. Hence, you can "
"replace methods from the superclass simply by defining a method with the "
"same name."
msgstr ""

#: src/reference/nested/classes.md:55
msgid "With"
msgstr ""

#: src/reference/nested/classes.md:59
msgid ""
"The `with` keyword is used together with `is` to insert additional methods "
"into a class definition _without_ making them the superclass. These are "
"often called `mixins`. These methods are inserted after the superclass's "
"methods. Multiple classes can be specified after `with`; they are added in "
"the order specified."
msgstr ""

#: src/reference/nested/classes.md:69
msgid ""
"Here `B` is the superclass of `A`, but methods defined by `C` and `D` are "
"also available to `A`. If `B`, `C` and `D` define methods with the same "
"name, those in `C` take precedence over any in `B` and those in `D` take "
"precedence over `B` and `C`. "
msgstr ""

#: src/reference/nested/classes.md:71
msgid "Self"
msgstr ""

#: src/reference/nested/classes.md:74
msgid ""
"The `self` keyword is used to access an object's properties and methods from "
"within its definition."
msgstr ""

#: src/reference/nested/classes.md:82
msgid "\"Driving my ${self.type}.\""
msgstr ""

#: src/reference/nested/classes.md:86
msgid "Super"
msgstr ""

#: src/reference/nested/classes.md:89
msgid ""
"The keyword `super` allows you to access methods provided by an object's "
"superclass rather than its own. This is particularly useful when the "
"programmer wants a class to extend the functionality of a parent class, but "
"needs to make sure the old behavior is still maintained."
msgstr ""

#: src/reference/nested/classes.md:91
msgid "For example, consider the following pair of classes:"
msgstr ""

#: src/reference/nested/classes.md:102
msgid "\"Delicious soup!\""
msgstr ""

#: src/reference/nested/classes.md:108
msgid "The subclass Soup uses `super` to call the original initializer."
msgstr ""

#: src/reference/nested/classes.md:110
msgid "Objects"
msgstr ""

#: src/reference/nested/classes.md:116
msgid ""
"Objects in Morpho are created by calling a constructor function, which "
"usually has the same name as the class of the object: "
msgstr ""

#: src/reference/nested/classes.md:119
msgid "// 50% gray \n"
msgstr ""

#: src/reference/nested/classes.md:122
msgid "You can store information in an object by assigning to its properties: "
msgstr ""

#: src/reference/nested/classes.md:128
msgid "and you can read from them similarly:"
msgstr ""

#: src/reference/nested/classes.md:134
msgid ""
"An object's `class` determines the methods that can be used on the object. "
"You call them using the . operator:"
msgstr ""

#: src/reference/nested/classes.md:140
msgid "See also `class`. "
msgstr ""

#: src/reference/nested/classes.md:144
msgid "Has"
msgstr ""

#: src/reference/nested/classes.md:147
msgid ""
"The `has` method is used to test if an object has a particular property:"
msgstr ""

#: src/reference/nested/classes.md:150 src/reference/nested/classes.md:167
#: src/reference/nested/classes.md:184 src/reference/nested/classes.md:190
#: src/reference/nested/errors.md:185
msgid "\"foo\""
msgstr ""

#: src/reference/nested/classes.md:153
msgid "If you call `has` with no parameters, "
msgstr ""

#: src/reference/nested/classes.md:159
msgid "it returns a list of all property labels that an object has. "
msgstr ""

#: src/reference/nested/classes.md:161
msgid "Respondsto"
msgstr ""

#: src/reference/nested/classes.md:164
msgid ""
"The `respondsto` method is used to test if an object provides a particular "
"method: "
msgstr ""

#: src/reference/nested/classes.md:170
msgid "If you call `respondsto` with no parameters, "
msgstr ""

#: src/reference/nested/classes.md:176
msgid "it returns a list of all methods that an object has available. "
msgstr ""

#: src/reference/nested/classes.md:178
msgid "Invoke"
msgstr ""

#: src/reference/nested/classes.md:181
msgid ""
"The `invoke` method is used to invoke a method from its label and a list of "
"parameters: "
msgstr ""

#: src/reference/nested/classes.md:184
msgid "\"has\""
msgstr ""

#: src/reference/nested/classes.md:187
msgid "is equivalent to:"
msgstr ""

#: src/reference/nested/classes.md:193
msgid "Clss"
msgstr ""

#: src/reference/nested/classes.md:196
msgid "The `clss` method is used to get the class to which an object belongs. "
msgstr ""

#: src/reference/nested/modules.md:9
msgid ""
"Morpho is extensible and provides a convenient module system that works like "
"standard libraries in other languages. Modules may define useful variables, "
"functions and classes, and can be made available using the `import` keyword. "
"For example,"
msgstr ""

#: src/reference/nested/modules.md:15
msgid "loads the `color` module that provides functionality related to color."
msgstr ""

#: src/reference/nested/modules.md:17
msgid ""
"You can create your own modules; they're just regular morpho files that are "
"stored in a standard place. On UNIX platforms, this is `/usr/local/share/"
"morpho/modules`."
msgstr ""

#: src/reference/nested/modules.md:21
msgid "Import"
msgstr ""

#: src/reference/nested/modules.md:25
msgid ""
"Import provides access to the module system and including code from multiple "
"source files."
msgstr ""

#: src/reference/nested/modules.md:27
msgid "To import code from another file, use import with the filename:"
msgstr ""

#: src/reference/nested/modules.md:30
msgid "\"file.morpho\""
msgstr ""

#: src/reference/nested/modules.md:33
msgid ""
"which immediately includes all the contents of `\"file.morpho\"`. Any "
"classes, functions or variables defined in that file can now be used, which "
"allows you to divide your program into multiple source files."
msgstr ""

#: src/reference/nested/modules.md:35
msgid ""
"Morpho provides a number of built in modules--and you can write your own--"
"which can be loaded like this:"
msgstr ""

#: src/reference/nested/modules.md:41
msgid "which imports the `color` module."
msgstr ""

#: src/reference/nested/modules.md:43
msgid ""
"You can selectively import symbols from a modules by using the `for` keyword:"
msgstr ""

#: src/reference/nested/modules.md:49
msgid "which imports only the `HueMap` class and the `Red` variable."
msgstr ""

#: src/reference/nested/modules.md:51
msgid ""
"You can also import a module using the 'as' keyword to place the symbols in "
"a specified namespace:"
msgstr ""

#: src/reference/nested/modules.md:57
msgid "You can then use refer to specific symbols like this: "
msgstr ""

#: src/reference/nested/modules.md:63
msgid "(See the help topic 'namespaces' for more information.)"
msgstr ""

#: src/reference/nested/modules.md:65
msgid "Namespaces"
msgstr ""

#: src/reference/nested/modules.md:69
msgid ""
"A namespace is a collection of symbols that is imported from a module.  You "
"identify a namespace using the 'as' keyword when importing the module like "
"this: "
msgstr ""

#: src/reference/nested/modules.md:73
msgid "// 'col' is the namespace\n"
msgstr ""

#: src/reference/nested/modules.md:76
msgid ""
"Everything defined by the module with a unique symbol, including classes, "
"functions and global variables, can be identified using the namespace, e.g. "
msgstr ""

#: src/reference/nested/modules.md:82
msgid ""
"Since the symbols are only are defined in the namespace you imported them "
"into, you can't refer to them directly: "
msgstr ""

#: src/reference/nested/modules.md:88
msgid ""
"Using namespaces is recommended, becuase it helps prevent conflicts between "
"modules."
msgstr ""

#: src/reference/nested/help.md:7
msgid ""
"Morpho provides an online help system. To get help about a topic called "
"`topicname`, type"
msgstr ""

#: src/reference/nested/help.md:13
msgid ""
"A list of available topics is provided below and includes language keywords "
"like `class`, `fn` and `for`, built in classes like `Matrix` and `File` or "
"information about functions like `exp` and `random`."
msgstr ""

#: src/reference/nested/help.md:15
msgid "Some topics have additional subtopics: to access these type"
msgstr ""

#: src/reference/nested/help.md:21
msgid ""
"For example, to get help on a method for a particular class, you could type"
msgstr ""

#: src/reference/nested/help.md:27
msgid "Note that `help` ignores all punctuation."
msgstr ""

#: src/reference/nested/help.md:29
msgid "You can also use `?` as a shorthand synonym for `help`"
msgstr ""

#: src/reference/nested/help.md:35
msgid ""
"A useful feature is that, if an error occurs, simply type `help` to get more "
"information about the error."
msgstr ""

#: src/reference/nested/help.md:39
msgid "Quit"
msgstr ""

#: src/reference/nested/help.md:42
msgid ""
"The `quit` CLI command quits `morpho` run in interactive mode and returns to "
"the shell."
msgstr ""

#: src/reference/nested/errors.md:8
msgid ""
"When an error occurs in running a morpho program, an error message is "
"displayed together with an explanation of where in the program that the "
"error happened."
msgstr ""

#: src/reference/nested/errors.md:10
msgid "You can make your own custom errors using the `Error` class: "
msgstr ""

#: src/reference/nested/errors.md:13
msgid "\"A message\""
msgstr ""

#: src/reference/nested/errors.md:16
msgid ""
"Use the `throw` method to raise the error, interrupting execution unless the "
"error is caught: "
msgstr ""

#: src/reference/nested/errors.md:22
msgid "or "
msgstr ""

#: src/reference/nested/errors.md:25
msgid "\"A custom message\""
msgstr ""

#: src/reference/nested/errors.md:28
msgid ""
"You can also use the `warning` method to alert the user of a potential issue "
"that doesn't need the program to be interrupted. "
msgstr ""

#: src/reference/nested/errors.md:36
msgid "Alloc"
msgstr ""

#: src/reference/nested/errors.md:39
msgid ""
"This error may occur when creating new objects or resizing them. It "
"typically indicates that the computer is under memory pressure."
msgstr ""

#: src/reference/nested/errors.md:41
msgid "Intrnl"
msgstr ""

#: src/reference/nested/errors.md:44
msgid ""
"This error indicates an internal problem with morpho. Please contact the "
"developers for support."
msgstr ""

#: src/reference/nested/errors.md:46
msgid "InvldOp"
msgstr ""

#: src/reference/nested/errors.md:49
msgid ""
"This error occurs when an operator like `+` or `-` is given operands that it "
"doesn't understand. For example,"
msgstr ""

#: src/reference/nested/errors.md:52
msgid "\"Goodbye\" // Causes 'InvldOp'\n"
msgstr ""

#: src/reference/nested/errors.md:55
msgid ""
"causes this error because the multiplication operator doesn't know how to "
"multiply strings."
msgstr ""

#: src/reference/nested/errors.md:57
msgid ""
"If the operands are objects, this means that the objects don't provide a "
"method for the requested operation, e.g. for"
msgstr ""

#: src/reference/nested/errors.md:63
msgid ""
"`object1` would need to provide a `div()` method that can successfully "
"handle `object2`."
msgstr ""

#: src/reference/nested/errors.md:65
msgid "CnctFld"
msgstr ""

#: src/reference/nested/errors.md:68
msgid ""
"This error occurs when concatenation of strings or other objects fails, "
"typically because of low memory."
msgstr ""

#: src/reference/nested/errors.md:70
msgid "Uncallable"
msgstr ""

#: src/reference/nested/errors.md:73
msgid ""
"This error occurs when you try to call something that isn't a method or a "
"function. Here, we initialize a variable with a string and call it:"
msgstr ""

#: src/reference/nested/errors.md:76
msgid "\"Not a function\""
msgstr ""

#: src/reference/nested/errors.md:77
msgid "// Causes 'Uncallable'\n"
msgstr ""

#: src/reference/nested/errors.md:80
msgid "GlblRtrn"
msgstr ""

#: src/reference/nested/errors.md:83
msgid ""
"This error occurs when morpho encounters a `return` keyword outside of a "
"function or method definition."
msgstr ""

#: src/reference/nested/errors.md:85
msgid "InstFail"
msgstr ""

#: src/reference/nested/errors.md:88
msgid ""
"This error occurs when morpho tried to create a new object, but something "
"went wrong."
msgstr ""

#: src/reference/nested/errors.md:90
msgid "NotAnObj"
msgstr ""

#: src/reference/nested/errors.md:93
msgid ""
"This error occurs if you try to access a property of something that isn't an "
"object:"
msgstr ""

#: src/reference/nested/errors.md:100
msgid "ObjLcksPrp"
msgstr ""

#: src/reference/nested/errors.md:103
msgid ""
"This error occurs if you try to access a property or method that hasn't been "
"defined for an object:"
msgstr ""

#: src/reference/nested/errors.md:110 src/reference/nested/selection.md:33
#: src/reference/nested/file.md:21
msgid "or"
msgstr ""

#: src/reference/nested/errors.md:116
msgid "NoInit"
msgstr ""

#: src/reference/nested/errors.md:119
msgid ""
"This error can occur if you try to create a new object from a class that "
"doesn't have an `init` method:"
msgstr ""

#: src/reference/nested/errors.md:126
msgid ""
"Here, the argument to `Foo` causes the `NoInit` error because no `init` "
"method is available to process it."
msgstr ""

#: src/reference/nested/errors.md:128
msgid "NotAnInst"
msgstr ""

#: src/reference/nested/errors.md:131
msgid ""
"This error occurs if you try to invoke a method on something that isn't an "
"object:"
msgstr ""

#: src/reference/nested/errors.md:138
msgid "ClssLcksMthd"
msgstr ""

#: src/reference/nested/errors.md:141
msgid ""
"This error occurs if you try to invoke a method on a class that doesn't "
"exist:"
msgstr ""

#: src/reference/nested/errors.md:148
msgid "InvldArgs"
msgstr ""

#: src/reference/nested/errors.md:151
msgid ""
"This error occurs if you call a function with the wrong number of arguments:"
msgstr ""

#: src/reference/nested/errors.md:158
msgid "NotIndxbl"
msgstr ""

#: src/reference/nested/errors.md:161
msgid ""
"This error occurs if you try to index something that isn't a collection:"
msgstr ""

#: src/reference/nested/errors.md:168
msgid "IndxBnds"
msgstr ""

#: src/reference/nested/errors.md:171
msgid ""
"This error can occur when selecting an entry from a collection object (such "
"as a list) if the index supplied is bigger than the number of entries:"
msgstr ""

#: src/reference/nested/errors.md:178
msgid "NonNmIndx"
msgstr ""

#: src/reference/nested/errors.md:181
msgid ""
"This error occurs if you try to index an array with a non-numerical index:"
msgstr ""

#: src/reference/nested/errors.md:185
msgid "\"bar\""
msgstr ""

#: src/reference/nested/errors.md:188
msgid "ArrayDim"
msgstr ""

#: src/reference/nested/errors.md:189
msgid "\\[tagarraydim\\]: # arraydim"
msgstr ""

#: src/reference/nested/errors.md:191
msgid ""
"This error occurs if you try to index an array with the wrong number of "
"indices:"
msgstr ""

#: src/reference/nested/errors.md:198
msgid "DbgQuit"
msgstr ""

#: src/reference/nested/errors.md:201
msgid ""
"This notification is generated after selecting `Quit` within the debugger. "
"Execution of the program is halted and control returns to the user."
msgstr ""

#: src/reference/nested/errors.md:203
msgid "SymblUndf"
msgstr ""

#: src/reference/nested/errors.md:206
msgid ""
"This error occurs if you refer to something that has not been previously "
"declared, for example trying to use a variable of call a function that "
"doesn't exist. It's possible that the symbol is spelt incorrectly, or that "
"the capitalization doesn't match the definition (_morpho_ symbols are case-"
"sensitive)."
msgstr ""

#: src/reference/nested/errors.md:208
msgid ""
"A common problem is to try to assign to a variable that hasn't yet been "
"declared:"
msgstr ""

#: src/reference/nested/errors.md:214
msgid "To fix this, prefix with `var`:"
msgstr ""

#: src/reference/nested/errors.md:221
msgid "MtrxIncmptbl"
msgstr ""

#: src/reference/nested/errors.md:224
msgid ""
"This error occurs when an arithmetic operation is performed on two "
"'incompatible' matrices. For example, two matrices must have the same "
"dimensions, i.e. the same number of rows and columns, to be added or "
"subtracted,"
msgstr ""

#: src/reference/nested/errors.md:229 src/reference/nested/errors.md:238
msgid "// generates a `MtrxIncmptbl` error.\n"
msgstr ""

#: src/reference/nested/errors.md:232
msgid ""
"Or to be multiplied together, the number of columns of the left hand matrix "
"must equal the number of rows of the right hand matrix."
msgstr ""

#: src/reference/nested/errors.md:237
msgid "// ok\n"
msgstr ""

#: src/reference/nested/builtin.md:4
msgid "Builtin functions"
msgstr ""

#: src/reference/nested/builtin.md:7
msgid "Morpho provides a number of built-in functions."
msgstr ""

#: src/reference/nested/builtin.md:11
msgid "Random"
msgstr ""

#: src/reference/nested/builtin.md:15
msgid ""
"The `random` function generates a random number from a uniform distribution "
"on the interval \\[0,1\\]."
msgstr ""

#: src/reference/nested/builtin.md:21
msgid "See also `randomnormal` and `randomint`."
msgstr ""

#: src/reference/nested/builtin.md:23
msgid "Randomnormal"
msgstr ""

#: src/reference/nested/builtin.md:26
msgid ""
"The `randomnormal` function generates a random number from a normal "
"(gaussian) distribution with unit variance and zero offset."
msgstr ""

#: src/reference/nested/builtin.md:32
msgid "See also `random` and `randomint`."
msgstr ""

#: src/reference/nested/builtin.md:34
msgid "Randomint"
msgstr ""

#: src/reference/nested/builtin.md:37
msgid ""
"The `randomint` function generates a random integer with a specified maximum "
"value."
msgstr ""

#: src/reference/nested/builtin.md:40
msgid "// Generates a random integer [0,10)\n"
msgstr ""

#: src/reference/nested/builtin.md:43
msgid "isnil"
msgstr ""

#: src/reference/nested/builtin.md:46
msgid "Returns `true` if a value is `nil` or `false` otherwise."
msgstr ""

#: src/reference/nested/builtin.md:48
msgid "isint"
msgstr ""

#: src/reference/nested/builtin.md:51
msgid "Returns `true` if a value is an integer or `false` otherwise."
msgstr ""

#: src/reference/nested/builtin.md:53
msgid "isfloat"
msgstr ""

#: src/reference/nested/builtin.md:56
msgid ""
"Returns `true` if a value is a floating point number or `false` otherwise."
msgstr ""

#: src/reference/nested/builtin.md:58
msgid "isbool"
msgstr ""

#: src/reference/nested/builtin.md:61
msgid "Returns `true` if a value is a boolean or `false` otherwise."
msgstr ""

#: src/reference/nested/builtin.md:63
msgid "isobject"
msgstr ""

#: src/reference/nested/builtin.md:66
msgid "Returns `true` if a value is an object or `false` otherwise."
msgstr ""

#: src/reference/nested/builtin.md:68
msgid "isstring"
msgstr ""

#: src/reference/nested/builtin.md:71
msgid "Returns `true` if a value is a string or `false` otherwise."
msgstr ""

#: src/reference/nested/builtin.md:73
msgid "isclass"
msgstr ""

#: src/reference/nested/builtin.md:76
msgid "Returns `true` if a value is a class or `false` otherwise."
msgstr ""

#: src/reference/nested/builtin.md:78
msgid "isrange"
msgstr ""

#: src/reference/nested/builtin.md:81
msgid "Returns `true` if a value is a range or `false` otherwise."
msgstr ""

#: src/reference/nested/builtin.md:83
msgid "isdictionary"
msgstr ""

#: src/reference/nested/builtin.md:86
msgid "Returns `true` if a value is a dictionary or `false` otherwise."
msgstr ""

#: src/reference/nested/builtin.md:88
msgid "islist"
msgstr ""

#: src/reference/nested/builtin.md:91
msgid "Returns `true` if a value is a list or `false` otherwise."
msgstr ""

#: src/reference/nested/builtin.md:93
msgid "isarray"
msgstr ""

#: src/reference/nested/builtin.md:96
msgid "Returns `true` if a value is an array or `false` otherwise."
msgstr ""

#: src/reference/nested/builtin.md:98
msgid "ismatrix"
msgstr ""

#: src/reference/nested/builtin.md:101
msgid "Returns `true` if a value is a matrix or `false` otherwise."
msgstr ""

#: src/reference/nested/builtin.md:103
msgid "issparse"
msgstr ""

#: src/reference/nested/builtin.md:106
msgid "Returns `true` if a value is a sparse matrix or `false` otherwise."
msgstr ""

#: src/reference/nested/builtin.md:108
msgid "isinf"
msgstr ""

#: src/reference/nested/builtin.md:111
msgid "Returns `true` if a value is infinite or `false` otherwise."
msgstr ""

#: src/reference/nested/builtin.md:113
msgid "isnan"
msgstr ""

#: src/reference/nested/builtin.md:116
msgid "Returns `true` if a value is a Not a Number or `false` otherwise."
msgstr ""

#: src/reference/nested/builtin.md:118
msgid "iscallable"
msgstr ""

#: src/reference/nested/builtin.md:121
msgid "Returns `true` if a value is callable or `false` otherwise."
msgstr ""

#: src/reference/nested/builtin.md:123
msgid "isfinite"
msgstr ""

#: src/reference/nested/builtin.md:126
msgid "Returns `true` if a value is finite or `false` otherwise."
msgstr ""

#: src/reference/nested/builtin.md:129 src/reference/nested/builtin.md:139
msgid "// expect: true \n"
msgstr ""

#: src/reference/nested/builtin.md:130
msgid "// expect: false \n"
msgstr ""

#: src/reference/nested/builtin.md:133
msgid "isnumber"
msgstr ""

#: src/reference/nested/builtin.md:136
msgid "Returns `true` if a value is a real number, or `false` otherwise."
msgstr ""

#: src/reference/nested/builtin.md:140
msgid "// expect: false\n"
msgstr ""

#: src/reference/nested/builtin.md:143
msgid "ismesh"
msgstr ""

#: src/reference/nested/builtin.md:146
msgid "Returns `true` if a value is a `Mesh`, or `false` otherwise."
msgstr ""

#: src/reference/nested/builtin.md:148
msgid "isselection"
msgstr ""

#: src/reference/nested/builtin.md:151
msgid "Returns `true` if a value is a `Selection`, or `false` otherwise."
msgstr ""

#: src/reference/nested/builtin.md:153
msgid "isfield"
msgstr ""

#: src/reference/nested/builtin.md:156
msgid "Returns `true` if a value is a `Field`, or `false` otherwise."
msgstr ""

#: src/reference/nested/builtin.md:158
msgid "Apply"
msgstr ""

#: src/reference/nested/builtin.md:161
msgid "Apply calls a function with the arguments provided as a list:"
msgstr ""

#: src/reference/nested/builtin.md:164
msgid "// calls f(0.5, 0.5) \n"
msgstr ""

#: src/reference/nested/builtin.md:167
msgid ""
"It's often useful where a function or method and/or the number of parameters "
"isn't known ahead of time. The first parameter to apply can be any callable "
"object, including a method invocation or a closure. "
msgstr ""

#: src/reference/nested/builtin.md:169
msgid ""
"You may also instead omit the list and use apply with multiple arguments: "
msgstr ""

#: src/reference/nested/builtin.md:172
msgid "// calls f(0.5, 0.5)\n"
msgstr ""

#: src/reference/nested/builtin.md:175
msgid ""
"There is one edge case that occurs when you want to call a function that "
"accepts a single list as a parameter. In this case, enclose the list in "
"another list: "
msgstr ""

#: src/reference/nested/builtin.md:178
msgid "// equivalent to f([1,2])\n"
msgstr ""

#: src/reference/nested/builtin.md:181
msgid "Abs"
msgstr ""

#: src/reference/nested/builtin.md:184
msgid "Returns the absolute value of a number: "
msgstr ""

#: src/reference/nested/builtin.md:187
msgid "// prints 10 \n"
msgstr ""

#: src/reference/nested/builtin.md:190
msgid "Sign"
msgstr ""

#: src/reference/nested/builtin.md:193
msgid "Gives the sign of a number: "
msgstr ""

#: src/reference/nested/builtin.md:197
msgid "// expect: -1\n"
msgstr ""

#: src/reference/nested/builtin.md:198 src/reference/nested/builtin.md:207
#: src/reference/nested/functionals.md:164
msgid "// expect: 0\n"
msgstr ""

#: src/reference/nested/builtin.md:201
msgid "Arctan"
msgstr ""

#: src/reference/nested/builtin.md:204
msgid ""
"Returns the arctangent of an input value that lies from `-Inf` to `Inf`. You "
"can use one argument:"
msgstr ""

#: src/reference/nested/builtin.md:210
msgid "or use two arguments to return the angle in the correct quadrant:"
msgstr ""

#: src/reference/nested/builtin.md:216
msgid "Note the order `x`, `y` differs from some other languages."
msgstr ""

#: src/reference/nested/builtin.md:218
msgid "Exp"
msgstr ""

#: src/reference/nested/builtin.md:221
msgid "Exponential function `e^x`. Inverse of `log`."
msgstr ""

#: src/reference/nested/builtin.md:225
msgid "// expect: -1 + 0im\n"
msgstr ""

#: src/reference/nested/builtin.md:228
msgid "Log"
msgstr ""

#: src/reference/nested/builtin.md:231
msgid "Natural logarithm function. Inverse of `exp`."
msgstr ""

#: src/reference/nested/builtin.md:234 src/reference/nested/builtin.md:252
#: src/reference/nested/builtin.md:261 src/reference/nested/builtin.md:288
#: src/reference/nested/builtin.md:297 src/reference/nested/builtin.md:306
#: src/reference/nested/builtin.md:315
msgid "// expect: 0 \n"
msgstr ""

#: src/reference/nested/builtin.md:237
msgid "Log10"
msgstr ""

#: src/reference/nested/builtin.md:240
msgid "Base 10 logarithm function."
msgstr ""

#: src/reference/nested/builtin.md:246
msgid "Sin"
msgstr ""

#: src/reference/nested/builtin.md:249
msgid "Sine trigonometric function."
msgstr ""

#: src/reference/nested/builtin.md:255
msgid "Sinh"
msgstr ""

#: src/reference/nested/builtin.md:258
msgid "Hyperbolic sine trigonometric function."
msgstr ""

#: src/reference/nested/builtin.md:264
msgid "Cos"
msgstr ""

#: src/reference/nested/builtin.md:267
msgid "Cosine trigonometric function."
msgstr ""

#: src/reference/nested/builtin.md:273
msgid "Cosh"
msgstr ""

#: src/reference/nested/builtin.md:276
msgid "Hyperbolic cosine trigonometric function."
msgstr ""

#: src/reference/nested/builtin.md:282
msgid "Tan"
msgstr ""

#: src/reference/nested/builtin.md:285
msgid "Tangent trigonometric function."
msgstr ""

#: src/reference/nested/builtin.md:291
msgid "Tanh"
msgstr ""

#: src/reference/nested/builtin.md:294
msgid "Hyperbolic tangent trigonometric function."
msgstr ""

#: src/reference/nested/builtin.md:300
msgid "Asin"
msgstr ""

#: src/reference/nested/builtin.md:303
msgid ""
"Inverse sine trigonometric function. Returns a value on the interval    `[-"
"Pi/2,Pi/2]`."
msgstr ""

#: src/reference/nested/builtin.md:309
msgid "Acos"
msgstr ""

#: src/reference/nested/builtin.md:312
msgid ""
"Inverse cosine trigonometric function. Returns a value on the interval  `[-"
"Pi/2,Pi/2]`."
msgstr ""

#: src/reference/nested/builtin.md:318
msgid "Sqrt"
msgstr ""

#: src/reference/nested/builtin.md:321
msgid "Square root function."
msgstr ""

#: src/reference/nested/builtin.md:327
msgid "Min"
msgstr ""

#: src/reference/nested/builtin.md:330
msgid ""
"Finds the minimum value of its arguments. If any of the arguments are "
"Objects and are enumerable, (e.g. a `List`), `min` will search inside them "
"for a minimum value. Accepts any number of arguments. "
msgstr ""

#: src/reference/nested/builtin.md:335
msgid "// expect: -2 \n"
msgstr ""

#: src/reference/nested/builtin.md:338
msgid "Max"
msgstr ""

#: src/reference/nested/builtin.md:341
msgid ""
"Finds the maximum value of its arguments. If any of the arguments are "
"Objects and are enumerable, (e.g. a `List`), `max` will search inside them "
"for a maximum value. Accepts any number of arguments. "
msgstr ""

#: src/reference/nested/builtin.md:344 src/reference/nested/builtin.md:346
msgid "// expect: 3 \n"
msgstr ""

#: src/reference/nested/builtin.md:345
msgid "// expect: 3\n"
msgstr ""

#: src/reference/nested/builtin.md:349
msgid "Bounds"
msgstr ""

#: src/reference/nested/builtin.md:352
msgid ""
"Returns both the results of `min` and `max` as a list, Providing a set of "
"bounds for its arguments and any enumerable objects within them."
msgstr ""

#: src/reference/nested/builtin.md:355
msgid "// expect: [1,3]\n"
msgstr ""

#: src/reference/nested/builtin.md:356
msgid "// expect: [-1,3]\n"
msgstr ""

#: src/reference/data_types.md:3
msgid ""
"This section describes the various data types like `List`'s, `Matrix` "
"objects, etc."
msgstr ""

#: src/reference/nested/array.md:7
msgid ""
"Arrays are collection objects that can have any number of indices. Their "
"size is set when they are created:"
msgstr ""

#: src/reference/nested/array.md:15
msgid "Values can be retrieved with appropriate indices:"
msgstr ""

#: src/reference/nested/array.md:21
msgid "Arrays can be indexed with slices:"
msgstr ""

#: src/reference/nested/array.md:26
msgid "Any morpho value can be stored in an array element"
msgstr ""

#: src/reference/nested/array.md:34 src/reference/nested/matrix.md:82
msgid "Dimensions"
msgstr ""

#: src/reference/nested/array.md:37
msgid "Get the dimensions of an Array object:"
msgstr ""

#: src/reference/nested/array.md:41
msgid "// expect: [ 2, 2 ]\n"
msgstr ""

#: src/reference/nested/complex.md:8
msgid ""
"Morpho provides complex numbers. The keyword `im` is used to denote the "
"imaginary part of a complex number:"
msgstr ""

#: src/reference/nested/complex.md:15
msgid "Print values on the unit circle in the complex plane:"
msgstr ""

#: src/reference/nested/complex.md:22
msgid "Get the real and imaginary parts of a complex number:"
msgstr ""

#: src/reference/nested/complex.md:29
msgid "or alternatively:"
msgstr ""

#: src/reference/nested/complex.md:38
msgid "Angle"
msgstr ""

#: src/reference/nested/complex.md:41
msgid ""
"Returns the angle `phi` associated with the polar representation of a "
"complex number `r*exp(im*phi)`:"
msgstr ""

#: src/reference/nested/complex.md:47
msgid "Conj"
msgstr ""

#: src/reference/nested/complex.md:51
msgid "Returns the complex conjugate of a number:"
msgstr ""

#: src/reference/nested/list.md:7
msgid ""
"Lists are collection objects that contain a sequence of values each "
"associated with an integer index."
msgstr ""

#: src/reference/nested/list.md:9
msgid "Create a list like this:"
msgstr ""

#: src/reference/nested/list.md:15 src/reference/nested/tuple.md:15
msgid "Look up values using index notation:"
msgstr ""

#: src/reference/nested/list.md:21
msgid ""
"Indexing can also be done with slices: list\\[0..2\\] list\\[\\[0,1,3\\]\\]"
msgstr ""

#: src/reference/nested/list.md:25
msgid "You can change list entries like this:"
msgstr ""

#: src/reference/nested/list.md:31
msgid "Create an empty list:"
msgstr ""

#: src/reference/nested/list.md:37
msgid "Loop over elements of a list:"
msgstr ""

#: src/reference/nested/list.md:45
msgid "Append"
msgstr ""

#: src/reference/nested/list.md:48
msgid "Adds an element to the end of a list:"
msgstr ""

#: src/reference/nested/list.md:55 src/reference/nested/kdtree.md:51
msgid "Insert"
msgstr ""

#: src/reference/nested/list.md:58
msgid "Inserts an element into a list at a specified index:"
msgstr ""

#: src/reference/nested/list.md:63
msgid "// prints [ 1, Foo, 2, 3 ]\n"
msgstr ""

#: src/reference/nested/list.md:66
msgid "Pop"
msgstr ""

#: src/reference/nested/list.md:69
msgid "Remove the last element from a list, returning the element removed:"
msgstr ""

#: src/reference/nested/list.md:75
msgid "If an integer argument is supplied, returns and removes that element:"
msgstr ""

#: src/reference/nested/list.md:79
msgid "// prints '2'\n"
msgstr ""

#: src/reference/nested/list.md:80
msgid "// prints [ 1, 3 ]\n"
msgstr ""

#: src/reference/nested/list.md:83
msgid "Sort"
msgstr ""

#: src/reference/nested/list.md:86
msgid "Sorts the contents of a list into ascending order:"
msgstr ""

#: src/reference/nested/list.md:92
msgid ""
"Note that this sorts the list \"in place\" (i.e. it modifies the order of "
"the list on which it is invoked) and hence returns `nil`."
msgstr ""

#: src/reference/nested/list.md:94
msgid "You can provide your own function to use to compare values in the list"
msgstr ""

#: src/reference/nested/list.md:100
msgid ""
"This function should return a negative value if `a<b`, a positive value if "
"`a>b` and `0` if `a` and `b` are equal."
msgstr ""

#: src/reference/nested/list.md:102
msgid "Order"
msgstr ""

#: src/reference/nested/list.md:105
msgid ""
"Returns a list of indices that would, if used in order, would sort a list. "
"For example"
msgstr ""

#: src/reference/nested/list.md:109
msgid "// expect: [2,0,1]\n"
msgstr ""

#: src/reference/nested/list.md:112
msgid "would produce `[2,0,1]`"
msgstr ""

#: src/reference/nested/list.md:114
msgid "Remove"
msgstr ""

#: src/reference/nested/list.md:117
msgid "Remove any occurrences of a value from a list:"
msgstr ""

#: src/reference/nested/list.md:124 src/reference/nested/tuple.md:33
msgid "ismember"
msgstr ""

#: src/reference/nested/list.md:127
msgid "Tests if a value is a member of a list:"
msgstr ""

#: src/reference/nested/list.md:131 src/reference/nested/tuple.md:40
msgid "// expect: true\n"
msgstr ""

#: src/reference/nested/list.md:134
msgid "Add"
msgstr ""

#: src/reference/nested/list.md:137 src/reference/nested/tuple.md:46
msgid "Join two lists together:"
msgstr ""

#: src/reference/nested/list.md:141
msgid "// expect: [1,2,3,4,5,6]\n"
msgstr ""

#: src/reference/nested/list.md:144
msgid "Tuples"
msgstr ""

#: src/reference/nested/list.md:147
msgid "Generate all possible 2-tuples from a list:"
msgstr ""

#: src/reference/nested/list.md:153
msgid "produces `[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ] ... ]`."
msgstr ""

#: src/reference/nested/list.md:157
msgid "Sets"
msgstr ""

#: src/reference/nested/list.md:160
msgid "Generate all possible sets of order 2 from a list. "
msgstr ""

#: src/reference/nested/list.md:166
msgid "produces `[ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ]`."
msgstr ""

#: src/reference/nested/list.md:168
msgid ""
"Note that sets include only distinct elements from the list (no element is "
"repeated) and ordering is unimportant, hence only one of  `[ 1, 2 ]` and "
"`[ 2, 1 ]` is returned. "
msgstr ""

#: src/reference/nested/matrix.md:7
msgid ""
"The Matrix class provides support for matrices. A matrix can be initialized "
"with a given size,"
msgstr ""

#: src/reference/nested/matrix.md:13
msgid ""
"where all elements are initially set to zero. Alternatively, a matrix can be "
"created from an array,"
msgstr ""

#: src/reference/nested/matrix.md:19
msgid "or a Sparse matrix,"
msgstr ""

#: src/reference/nested/matrix.md:26
msgid "You can create a column vector like this,"
msgstr ""

#: src/reference/nested/matrix.md:32
msgid ""
"Finally, you can create a Matrix by assembling other matrices like this,"
msgstr ""

#: src/reference/nested/matrix.md:36
msgid "// produces a 4x4 matrix \n"
msgstr ""

#: src/reference/nested/matrix.md:39
msgid ""
"Once a matrix is created, you can use all the regular arithmetic operators "
"with matrix operands, e.g."
msgstr ""

#: src/reference/nested/matrix.md:46
msgid "You can retrieved individual matrix entries with specified indices:"
msgstr ""

#: src/reference/nested/matrix.md:52
msgid "or create a submatrix using slices:"
msgstr ""

#: src/reference/nested/matrix.md:56
msgid "The division operator is used to solve a linear system, e.g."
msgstr ""

#: src/reference/nested/matrix.md:67
msgid "yields the solution to the system a\\*x = b."
msgstr ""

#: src/reference/nested/matrix.md:71
msgid "Assign"
msgstr ""

#: src/reference/nested/matrix.md:74
msgid "Copies the contents of matrix B into matrix A: "
msgstr ""

#: src/reference/nested/matrix.md:80
msgid "The two matrices must have the same dimensions."
msgstr ""

#: src/reference/nested/matrix.md:85
msgid "Returns the dimensions of a matrix:"
msgstr ""

#: src/reference/nested/matrix.md:88
msgid "// Create a column matrix \n"
msgstr ""

#: src/reference/nested/matrix.md:89
msgid "// Expect: [ 3, 1 ]\n"
msgstr ""

#: src/reference/nested/matrix.md:92
msgid "Eigenvalues"
msgstr ""

#: src/reference/nested/matrix.md:95
msgid "Returns a list of eigenvalues of a Matrix:"
msgstr ""

#: src/reference/nested/matrix.md:99
msgid "// Expect: [1,-1]\n"
msgstr ""

#: src/reference/nested/matrix.md:102
msgid "Eigensystem"
msgstr ""

#: src/reference/nested/matrix.md:105
msgid "Returns the eigenvalues and eigenvectors of a Matrix:"
msgstr ""

#: src/reference/nested/matrix.md:112
msgid ""
"Eigensystem returns a two element list: The first element is a List of "
"eigenvalues. The second element is a Matrix containing the corresponding "
"eigenvectors as its columns:"
msgstr ""

#: src/reference/nested/matrix.md:115
msgid "// [ 1, -1 ]\n"
msgstr ""

#: src/reference/nested/matrix.md:117
msgid ""
"// [ 0.707107 -0.707107 ]\n"
"// [ 0.707107 0.707107 ]\n"
msgstr ""

#: src/reference/nested/matrix.md:122
msgid "Inner"
msgstr ""

#: src/reference/nested/matrix.md:125
msgid "Computes the Frobenius inner product between two matrices:"
msgstr ""

#: src/reference/nested/matrix.md:131
msgid "Outer"
msgstr ""

#: src/reference/nested/matrix.md:134
msgid "Computes the outer produce between two vectors: "
msgstr ""

#: src/reference/nested/matrix.md:140
msgid "Note that `outer` always treats both vectors as column vectors. "
msgstr ""

#: src/reference/nested/matrix.md:142
msgid "Inverse"
msgstr ""

#: src/reference/nested/matrix.md:145
msgid ""
"Returns the inverse of a matrix if it is invertible. Raises a `MtrxSnglr` "
"error if the matrix is singular. E.g."
msgstr ""

#: src/reference/nested/matrix.md:153
msgid ""
"yields the inverse of the matrix `m`, such that mi\\*m is the identity "
"matrix."
msgstr ""

#: src/reference/nested/matrix.md:156
msgid "Norm"
msgstr ""

#: src/reference/nested/matrix.md:159
msgid "Returns a matrix norm. By default the L2 norm is returned:"
msgstr ""

#: src/reference/nested/matrix.md:163
msgid "// Expect: sqrt(30) = 5.47723...\n"
msgstr ""

#: src/reference/nested/matrix.md:166
msgid "You can select a different norm by supplying an argument:"
msgstr ""

#: src/reference/nested/matrix.md:170
msgid "// Expect: 10 (L1 norm is sum of absolute values) \n"
msgstr ""

#: src/reference/nested/matrix.md:171
msgid "// Expect: 4.64159 (An unusual choice of norm)\n"
msgstr ""

#: src/reference/nested/matrix.md:172
msgid "// Expect: 4 (Inf-norm corresponds to maximum absolute value)\n"
msgstr ""

#: src/reference/nested/matrix.md:175
msgid "Reshape"
msgstr ""

#: src/reference/nested/matrix.md:178
msgid ""
"Changes the dimensions of a matrix such that the total number of elements "
"remains constant:"
msgstr ""

#: src/reference/nested/matrix.md:182
msgid "// 1 row, 4 columns\n"
msgstr ""

#: src/reference/nested/matrix.md:183
msgid "// Expect: [ 1, 2, 3, 4 ]\n"
msgstr ""

#: src/reference/nested/matrix.md:186
msgid "Note that elements are stored in column major-order."
msgstr ""

#: src/reference/nested/matrix.md:188
msgid "Sum"
msgstr ""

#: src/reference/nested/matrix.md:191
msgid "Returns the sum of all entries in a matrix:"
msgstr ""

#: src/reference/nested/matrix.md:197
msgid "Transpose"
msgstr ""

#: src/reference/nested/matrix.md:200
msgid "Returns the transpose of a matrix: "
msgstr ""

#: src/reference/nested/matrix.md:206
msgid "Trace"
msgstr ""

#: src/reference/nested/matrix.md:209
msgid ""
"Computes the trace (the sum of the diagonal elements) of a square matrix:"
msgstr ""

#: src/reference/nested/matrix.md:215
msgid "Roll"
msgstr ""

#: src/reference/nested/matrix.md:218
msgid "Rotates values in a Matrix about a given axis by a given shift:"
msgstr ""

#: src/reference/nested/matrix.md:224
msgid ""
"Elements that roll beyond the last position are re-introduced at the first."
msgstr ""

#: src/reference/nested/matrix.md:226
msgid "IdentityMatrix"
msgstr ""

#: src/reference/nested/matrix.md:229
msgid "Constructs an identity matrix of a specified size:"
msgstr ""

#: src/reference/nested/range.md:7
msgid ""
"Ranges represent a sequence of numerical values. There are two ways to "
"create them depending on whether the upper value is included or not:"
msgstr ""

#: src/reference/nested/range.md:10
msgid "// inclusive version, i.e. [1,2,3,4,5]\n"
msgstr ""

#: src/reference/nested/range.md:11
msgid "// exclusive version, i.e. [1,2,3,4]\n"
msgstr ""

#: src/reference/nested/range.md:14
msgid ""
"By default, the increment between values is 1, but you can use a different "
"value like this:"
msgstr ""

#: src/reference/nested/range.md:17
msgid "// 1 - 5 with an increment of 0.5.\n"
msgstr ""

#: src/reference/nested/range.md:20
msgid ""
"You can also create Range objects using the appropriate constructor function:"
msgstr ""

#: src/reference/nested/range.md:26
msgid "Ranges are particularly useful in writing loops:"
msgstr ""

#: src/reference/nested/range.md:32
msgid "They can easily be converted to a list of values:"
msgstr ""

#: src/reference/nested/range.md:38
msgid "To find the number of elements in a Range, use the `count` method"
msgstr ""

#: src/reference/nested/sparse.md:7
msgid ""
"The Sparse class provides support for sparse matrices. An empty sparse "
"matrix can be initialized with a given size,"
msgstr ""

#: src/reference/nested/sparse.md:13
msgid "Alternatively, a matrix can be created from an array of triplets,"
msgstr ""

#: src/reference/nested/sparse.md:19
msgid "For example,"
msgstr ""

#: src/reference/nested/sparse.md:25
msgid "creates the matrix"
msgstr ""

#: src/reference/nested/sparse.md:32
msgid ""
"Once a sparse matrix is created, you can use all the regular arithmetic "
"operators with matrix operands, e.g."
msgstr ""

#: src/reference/nested/string.md:7
msgid ""
"Strings represent textual information. They are written in Morpho like this:"
msgstr ""

#: src/reference/nested/string.md:10
msgid "\"hello world\""
msgstr ""

#: src/reference/nested/string.md:13
msgid "Unicode characters including emoji are supported."
msgstr ""

#: src/reference/nested/string.md:15
msgid ""
"You can also create strings using the constructor function `String`, which "
"takes any number of parameters:"
msgstr ""

#: src/reference/nested/string.md:18
msgid "\"World\""
msgstr ""

#: src/reference/nested/string.md:21
msgid ""
"A very useful feature, called _string interpolation_, enables the results of "
"any morpho expression can be interpolated into a string. Here, the values of "
"`i` and `func(i)` will be inserted into the string as it is created:"
msgstr ""

#: src/reference/nested/string.md:24
msgid "\"${i}: ${func(i)}\""
msgstr ""

#: src/reference/nested/string.md:27
msgid "To get an individual character, use index notatation"
msgstr ""

#: src/reference/nested/string.md:30 src/reference/nested/string.md:36
#: src/reference/nested/string.md:42
msgid "\"morpho\""
msgstr ""

#: src/reference/nested/string.md:33
msgid "You can loop over each character like this:"
msgstr ""

#: src/reference/nested/string.md:39
msgid "Note that strings are immutable, and hence"
msgstr ""

#: src/reference/nested/string.md:46
msgid "raises an error."
msgstr ""

#: src/reference/nested/string.md:50
msgid "split"
msgstr ""

#: src/reference/nested/string.md:53
msgid ""
"The split method splits a String into a list of substrings. It takes one "
"argument, which is a string of characters to use to split the string:"
msgstr ""

#: src/reference/nested/string.md:56
msgid "\"1,2,3\""
msgstr ""

#: src/reference/nested/string.md:56
msgid "\",\""
msgstr ""

#: src/reference/nested/string.md:59
msgid "gives"
msgstr ""

#: src/reference/nested/tuple.md:7
msgid ""
"Tuples are collection objects that contain a sequence of values each "
"associated with an integer index. Unlike Lists, they can't be changed after "
"creation."
msgstr ""

#: src/reference/nested/tuple.md:9
msgid "Create a tuple like this:"
msgstr ""

#: src/reference/nested/tuple.md:21
msgid "Indexing can also be done with slices:"
msgstr ""

#: src/reference/nested/tuple.md:25
msgid "Loop over elements of a tuple:"
msgstr ""

#: src/reference/nested/tuple.md:36
msgid "Tests if a value is a member of a tuple:"
msgstr ""

#: src/reference/nested/tuple.md:43
msgid "Join"
msgstr ""

#: src/reference/nested/tuple.md:50
msgid "// expect: (1,2,3,4,5,6)\n"
msgstr ""

#: src/reference/computational_geometry.md:3
msgid ""
"This section provides the documentation for meshes, selections, fields and "
"functionals."
msgstr ""

#: src/reference/nested/field.md:7
msgid ""
"Fields are used to store information, including numbers or matrices, "
"associated with the elements of a `Mesh` object."
msgstr ""

#: src/reference/nested/field.md:9
msgid ""
"You can create a `Field` by applying a function to each of the vertices,"
msgstr ""

#: src/reference/nested/field.md:15
msgid "or by supplying a single constant value,"
msgstr ""

#: src/reference/nested/field.md:21
msgid ""
"Fields can then be added and subtracted using the `+` and `-` operators."
msgstr ""

#: src/reference/nested/field.md:23
msgid "To access elements of a `Field`, use index notation:"
msgstr ""

#: src/reference/nested/field.md:29 src/reference/nested/meshtools.md:20
#: src/reference/nested/meshtools.md:64
msgid "where"
msgstr ""

#: src/reference/nested/field.md:30
msgid "`grade` is the grade to select"
msgstr ""

#: src/reference/nested/field.md:31
msgid "`element` is the element id"
msgstr ""

#: src/reference/nested/field.md:32
msgid "`index` is the element index"
msgstr ""

#: src/reference/nested/field.md:34
msgid ""
"As a shorthand, it's possible to omit the grade and index; these are then "
"both assumed to be `0`:"
msgstr ""

#: src/reference/nested/field.md:45
msgid "Returns the Mesh associated with a Field object:"
msgstr ""

#: src/reference/nested/field.md:51
msgid "Grade"
msgstr ""

#: src/reference/nested/field.md:54
msgid ""
"To create fields that include grades other than just vertices, use the "
"`grade` option to `Field`. This can be just a grade index,"
msgstr ""

#: src/reference/nested/field.md:60
msgid ""
"which creates an empty field with `0` for each of the facets of the mesh "
"`mesh`."
msgstr ""

#: src/reference/nested/field.md:62
msgid ""
"You can store more than one item per element by supplying a list to the "
"`grade` option indicating how many items you want to store on each grade. "
"For example,"
msgstr ""

#: src/reference/nested/field.md:68
msgid ""
"stores two numbers on the line (grade 1) elements and one number on the "
"facets (grade 2) elements. Each number in the field is initialized to the "
"value `1.0`."
msgstr ""

#: src/reference/nested/field.md:70
msgid "Shape"
msgstr ""

#: src/reference/nested/field.md:73
msgid ""
"The `shape` method returns a list indicating the number of items stored on "
"each element of a particular grade. This has the same format as the list you "
"supply to the `grade` option of the `Field` constructor. For example,"
msgstr ""

#: src/reference/nested/field.md:79
msgid ""
"would indicate one item stored on each vertex and two items stored on each "
"facet."
msgstr ""

#: src/reference/nested/field.md:81
msgid "Op"
msgstr ""

#: src/reference/nested/field.md:84
msgid ""
"The `op` method applies a function to every item stored in a `Field`, "
"returning the result as elements of a new `Field` object. For example,"
msgstr ""

#: src/reference/nested/field.md:90
msgid "calls the `norm` method on each element stored in `f`."
msgstr ""

#: src/reference/nested/field.md:92
msgid ""
"Additional `Field` objects may be supplied as extra arguments to `op`. These "
"must have the same shape (the same number of items stored on each grade). "
"The function supplied to `op` will now be called with the corresponding "
"element from each field as arguments. For example,"
msgstr ""

#: src/reference/nested/field.md:98
msgid ""
"calculates an elementwise inner product between the elements of Fields `f` "
"and `g`."
msgstr ""

#: src/reference/nested/functionals.md:7
msgid ""
"A number of `functionals` are available in Morpho. Each of these represents "
"an integral over some `Mesh` and `Field` objects (on a particular "
"`Selection`) and are used to define energies and constraints in an "
"`OptimizationProblem` provided by the `optimize` module."
msgstr ""

#: src/reference/nested/functionals.md:9
msgid ""
"Many functionals are built in. Additional functionals are available by "
"importing the `functionals` module:"
msgstr ""

#: src/reference/nested/functionals.md:15
msgid "Functionals provide a number of standard methods:"
msgstr ""

#: src/reference/nested/functionals.md:17
msgid ""
"`total`(mesh) - returns the value of the integral with a provided mesh, "
"selection and fields"
msgstr ""

#: src/reference/nested/functionals.md:18
msgid ""
"`integrand`(mesh) - returns the contribution to the integral from each "
"element"
msgstr ""

#: src/reference/nested/functionals.md:19
msgid ""
"`gradient`(mesh) - returns the gradient of the functional with respect to "
"vertex motions."
msgstr ""

#: src/reference/nested/functionals.md:20
msgid ""
"`fieldgradient`(mesh, field) - returns the gradient of the functional with "
"respect to components of the field"
msgstr ""

#: src/reference/nested/functionals.md:22
msgid "Each of these may be called with a mesh, a field and a selection."
msgstr ""

#: src/reference/nested/functionals.md:26
msgid "Length"
msgstr ""

#: src/reference/nested/functionals.md:29
msgid ""
"A `Length` functional calculates the length of a line element in a mesh."
msgstr ""

#: src/reference/nested/functionals.md:31
msgid "Evaluate the length of a circular loop:"
msgstr ""

#: src/reference/nested/functionals.md:41
msgid "AreaEnclosed"
msgstr ""

#: src/reference/nested/functionals.md:44
msgid ""
"An `AreaEnclosed` functional calculates the area enclosed by a loop of line "
"elements."
msgstr ""

#: src/reference/nested/functionals.md:50
msgid "Area"
msgstr ""

#: src/reference/nested/functionals.md:53
msgid ""
"An `Area` functional calculates the area of the area elements in a mesh:"
msgstr ""

#: src/reference/nested/functionals.md:60
msgid "VolumeEnclosed"
msgstr ""

#: src/reference/nested/functionals.md:63
msgid ""
"A `VolumeEnclosed` functional is used to calculate the volume enclosed by a "
"surface. Note that this estimate may become inaccurate for highly deformed "
"surfaces."
msgstr ""

#: src/reference/nested/functionals.md:69
msgid "Volume"
msgstr ""

#: src/reference/nested/functionals.md:72
msgid "A `Volume` functional calculates the volume of volume elements."
msgstr ""

#: src/reference/nested/functionals.md:78
msgid "ScalarPotential"
msgstr ""

#: src/reference/nested/functionals.md:81
msgid "The `ScalarPotential` functional is applied to point elements."
msgstr ""

#: src/reference/nested/functionals.md:87
msgid ""
"You must supply a function (which may be anonymous) that returns the "
"potential. You may optionally provide a function that returns the gradient "
"as well at initialization:"
msgstr ""

#: src/reference/nested/functionals.md:93
msgid ""
"This functional is often used to constrain the mesh to the level set of a "
"function. For example, to confine a set of points to a sphere:"
msgstr ""

#: src/reference/nested/functionals.md:103
msgid "See the thomson example for use of this technique."
msgstr ""

#: src/reference/nested/functionals.md:105
msgid "LinearElasticity"
msgstr ""

#: src/reference/nested/functionals.md:108
msgid ""
"The `LinearElasticity` functional measures the linear elastic energy away "
"from a reference state."
msgstr ""

#: src/reference/nested/functionals.md:110
msgid "You must initialize with a reference mesh:"
msgstr ""

#: src/reference/nested/functionals.md:116
msgid "Manually set the poisson's ratio and grade to operate on:"
msgstr ""

#: src/reference/nested/functionals.md:123
msgid "EquiElement"
msgstr ""

#: src/reference/nested/functionals.md:126
msgid ""
"The `EquiElement` functional measures the discrepency between the size of "
"elements adjacent to each vertex. It can be used to equalize elements for "
"regularization purposes."
msgstr ""

#: src/reference/nested/functionals.md:128
msgid "LineCurvatureSq"
msgstr ""

#: src/reference/nested/functionals.md:131
msgid ""
"The `LineCurvatureSq` functional measures the integrated curvature squared "
"of a sequence of line elements."
msgstr ""

#: src/reference/nested/functionals.md:133
msgid "LineTorsionSq"
msgstr ""

#: src/reference/nested/functionals.md:136
msgid ""
"The `LineTorsionSq` functional measures the integrated torsion squared of a "
"sequence of line elements."
msgstr ""

#: src/reference/nested/functionals.md:138
msgid "MeanCurvatureSq"
msgstr ""

#: src/reference/nested/functionals.md:141
msgid ""
"The `MeanCurvatureSq` functional computes the integrated mean curvature over "
"a surface."
msgstr ""

#: src/reference/nested/functionals.md:143
msgid "GaussCurvature"
msgstr ""

#: src/reference/nested/functionals.md:146
msgid ""
"The `GaussCurvature` computes the integrated gaussian curvature over a "
"surface."
msgstr ""

#: src/reference/nested/functionals.md:148
msgid ""
"Note that for surfaces with a boundary, the integrand is correct only for "
"the interior points. To compute the geodesic curvature of the boundary in "
"that case, you can set the optional flag `geodesic` to `true` and compute "
"the total on the boundary selection. Here is an example for a 2D disk mesh."
msgstr ""

#: src/reference/nested/functionals.md:166
msgid "// expect: 2*Pi\n"
msgstr ""

#: src/reference/nested/functionals.md:169
msgid "GradSq"
msgstr ""

#: src/reference/nested/functionals.md:172
msgid ""
"The `GradSq` functional measures the integral of the gradient squared of a "
"field. The field can be a scalar, vector or matrix function."
msgstr ""

#: src/reference/nested/functionals.md:174
msgid "Initialize with the required field:"
msgstr ""

#: src/reference/nested/functionals.md:180
msgid "Nematic"
msgstr ""

#: src/reference/nested/functionals.md:183
msgid ""
"The `Nematic` functional measures the elastic energy of a nematic liquid "
"crystal."
msgstr ""

#: src/reference/nested/functionals.md:189
msgid ""
"There are a number of optional parameters that can be used to set the splay, "
"twist and bend constants:"
msgstr ""

#: src/reference/nested/functionals.md:195
msgid ""
"These are stored as properties of the object and can be retrieved as follows:"
msgstr ""

#: src/reference/nested/functionals.md:201
msgid "NematicElectric"
msgstr ""

#: src/reference/nested/functionals.md:204
msgid ""
"The `NematicElectric` functional measures the integral of a nematic and "
"electric coupling term integral((n.E)^2) where the electric field E may be "
"computed from a scalar potential or supplied as a vector."
msgstr ""

#: src/reference/nested/functionals.md:206
msgid "Initialize with a director field `nn` and a scalar potential `phi`:"
msgstr ""

#: src/reference/nested/functionals.md:211
msgid "NormSq"
msgstr ""

#: src/reference/nested/functionals.md:214
msgid ""
"The `NormSq` functional measures the elementwise L2 norm squared of a field."
msgstr ""

#: src/reference/nested/functionals.md:216
msgid "LineIntegral"
msgstr ""

#: src/reference/nested/functionals.md:219
msgid ""
"The `LineIntegral` functional computes the line integral of a function. You "
"supply an integrand function that takes a position matrix as an argument."
msgstr ""

#: src/reference/nested/functionals.md:221
msgid "To compute `integral(x^2+y^2)` over a line element:"
msgstr ""

#: src/reference/nested/functionals.md:227
msgid ""
"The function `tangent()` returns a unit vector tangent to the current "
"element:"
msgstr ""

#: src/reference/nested/functionals.md:233
#: src/reference/nested/functionals.md:254
#: src/reference/nested/functionals.md:281
msgid "You can also integrate functions that involve fields:"
msgstr ""

#: src/reference/nested/functionals.md:239
msgid ""
"where `n` is a vector field. The local interpolated value of this field is "
"passed to your integrand function. More than one field can be used; they are "
"passed as arguments to the integrand function in the order you supply them "
"to `LineIntegral`."
msgstr ""

#: src/reference/nested/functionals.md:241
#: src/reference/nested/functionals.md:268
#: src/reference/nested/functionals.md:289
msgid ""
"The gradient of a field is available within an integrand function using the "
"`gradient()` function."
msgstr ""

#: src/reference/nested/functionals.md:243
msgid "AreaIntegral"
msgstr ""

#: src/reference/nested/functionals.md:246
msgid ""
"The `AreaIntegral` functional computes the area integral of a function. You "
"supply an integrand function that takes a position matrix as an argument."
msgstr ""

#: src/reference/nested/functionals.md:248
msgid "To compute integral(x\\*y) over an area element:"
msgstr ""

#: src/reference/nested/functionals.md:260
msgid ""
"The local facet normal can be accessed in an integrand using the `normal()` "
"function:"
msgstr ""

#: src/reference/nested/functionals.md:266
msgid ""
"More than one field can be used; they are passed as arguments to the "
"integrand function in the order you supply them to `AreaIntegral`."
msgstr ""

#: src/reference/nested/functionals.md:270
msgid "VolumeIntegral"
msgstr ""

#: src/reference/nested/functionals.md:273
msgid ""
"The `VolumeIntegral` functional computes the volume integral of a function. "
"You supply an integrand function that takes a position matrix as an argument."
msgstr ""

#: src/reference/nested/functionals.md:275
msgid "To compute integral(x_y_z) over an volume element:"
msgstr ""

#: src/reference/nested/functionals.md:287
msgid ""
"More than one field can be used; they are passed as arguments to the "
"integrand function in the order you supply them to `VolumeIntegral`."
msgstr ""

#: src/reference/nested/functionals.md:291
msgid "Hydrogel"
msgstr ""

#: src/reference/nested/functionals.md:294
msgid ""
"The `Hydrogel` functional computes the Flory-Rehner energy over an element:"
msgstr ""

#: src/reference/nested/functionals.md:301
msgid ""
"The first three terms come from the Flory-Huggins mixing energy, whereas the "
"fourth term proportional to d comes from the Flory-Rehner elastic energy."
msgstr ""

#: src/reference/nested/functionals.md:305
msgid ""
"The value of phi is calculated from a reference mesh that you provide on "
"initializing the Functional: "
msgstr ""

#: src/reference/nested/functionals.md:312
msgid ""
"Here, a, b, c, d and phiref are parameters you can supply (they are `nil` by "
"default), V is the current volume and V0 is the reference volume of a given "
"element. You also need to supply the initial value of phi, labeled as phi0, "
"which is assumed to be the same for all the elements.  Manually set the "
"coefficients and grade to operate on:"
msgstr ""

#: src/reference/nested/mesh.md:7
msgid ""
"The `Mesh` class provides support for meshes. Meshes may consist of "
"different kinds of element, including vertices, line elements, facets or "
"area elements, tetrahedra or volume elements."
msgstr ""

#: src/reference/nested/mesh.md:9
msgid "To create a mesh, you can import it from a file:"
msgstr ""

#: src/reference/nested/mesh.md:12
msgid "\"sphere.mesh\""
msgstr ""

#: src/reference/nested/mesh.md:15
msgid ""
"or use one of the functions available in `meshtools` or `implicitmesh` "
"packages."
msgstr ""

#: src/reference/nested/mesh.md:17
msgid ""
"Each type of element is referred to as belonging to a different `grade`. "
"Point-like elements (vertices) are _grade 0_; line-like elements (edges) are "
"_grade 1_; area-like elements (facets; triangles) are _grade 2_ etc."
msgstr ""

#: src/reference/nested/mesh.md:19
msgid "The `plot` package includes functions to visualize meshes."
msgstr ""

#: src/reference/nested/mesh.md:23
msgid "Save"
msgstr ""

#: src/reference/nested/mesh.md:26
msgid "Saves a mesh as a .mesh file."
msgstr ""

#: src/reference/nested/mesh.md:29
msgid "\"new.mesh\""
msgstr ""

#: src/reference/nested/mesh.md:32
msgid "Vertexposition"
msgstr ""

#: src/reference/nested/mesh.md:35
msgid "Retrieves the position of a vertex given an id:"
msgstr ""

#: src/reference/nested/mesh.md:41
msgid "Setvertexposition"
msgstr ""

#: src/reference/nested/mesh.md:44
msgid "Sets the position of a vertex given an id and a position vector:"
msgstr ""

#: src/reference/nested/mesh.md:50
msgid "Addgrade"
msgstr ""

#: src/reference/nested/mesh.md:53
msgid ""
"Adds a new grade to a mesh. This is commonly used when, for example, a mesh "
"file includes facets but not edges. To add the missing edges:"
msgstr ""

#: src/reference/nested/mesh.md:59
msgid "Addsymmetry"
msgstr ""

#: src/reference/nested/mesh.md:62
msgid "Adds a symmetry to a mesh. Experimental in version 0.5."
msgstr ""

#: src/reference/nested/mesh.md:64
msgid "Maxgrade"
msgstr ""

#: src/reference/nested/mesh.md:67
msgid "Returns the highest grade element present:"
msgstr ""

#: src/reference/nested/mesh.md:73
msgid "Count"
msgstr ""

#: src/reference/nested/mesh.md:76
msgid ""
"Counts the number of elements. If no argument is provided, returns the "
"number of vertices. Otherwise, returns the number of elements present of a "
"given grade:"
msgstr ""

#: src/reference/nested/mesh.md:79
msgid "// Returns the number of area-like elements. \n"
msgstr ""

#: src/reference/nested/selection.md:7
msgid ""
"The Selection class enables you to select components of a mesh for later "
"use. You can supply a function that is applied to the coordinates of every "
"vertex in the mesh, or select components like boundaries."
msgstr ""

#: src/reference/nested/selection.md:9
msgid "Create an empty selection:"
msgstr ""

#: src/reference/nested/selection.md:15
msgid "Select vertices above the z=0 plane using an anonymous function:"
msgstr ""

#: src/reference/nested/selection.md:21
msgid "Select the boundary of a mesh:"
msgstr ""

#: src/reference/nested/selection.md:27
msgid "Selection objects can be composed using set operations:"
msgstr ""

#: src/reference/nested/selection.md:38
msgid ""
"To add additional grades, use the addgrade method. For example, to add areas:"
msgstr ""

#: src/reference/nested/selection.md:43
msgid "\\[showsubtopics\\]: # subtopics"
msgstr ""

#: src/reference/nested/selection.md:45
msgid "addgrade"
msgstr ""

#: src/reference/nested/selection.md:47
msgid ""
"Adds elements of the specified grade to a Selection. For example, to add "
"edges to an existing selection, use"
msgstr ""

#: src/reference/nested/selection.md:53
msgid ""
"By default, this only adds an element if _all_ vertices in the element are "
"currently selected. Sometimes, it's useful to be able to add elements for "
"which only some vertices are selected. The optional argument `partials` "
"allows you to do this:"
msgstr ""

#: src/reference/nested/selection.md:59 src/reference/nested/selection.md:69
msgid ""
"Note that this method modifies the existing selection, and does not generate "
"a new Selection object."
msgstr ""

#: src/reference/nested/selection.md:61
msgid "removegrade"
msgstr ""

#: src/reference/nested/selection.md:63
msgid ""
"Removes elements of the specified grade from a Selection. For example, to "
"remove edges from an existing selection, use"
msgstr ""

#: src/reference/nested/selection.md:71
msgid "idlistforgrade"
msgstr ""

#: src/reference/nested/selection.md:73
msgid "Returns a list of element ids included in the selection."
msgstr ""

#: src/reference/nested/selection.md:75
msgid "To find out which edges are selected:"
msgstr ""

#: src/reference/nested/selection.md:81
msgid "isselected"
msgstr ""

#: src/reference/nested/selection.md:83
msgid ""
"Checks if an element id is selected, returning `true` or `false` accordingly."
msgstr ""

#: src/reference/nested/selection.md:85
msgid "To check if edge number 5 is selected:"
msgstr ""

#: src/reference/io.md:3
msgid "This section provides the documentation for the `File` object."
msgstr ""

#: src/reference/nested/file.md:7
msgid ""
"The `File` class provides the capability to read from and write to files, or "
"to obtain the contents of a file in convenient formats."
msgstr ""

#: src/reference/nested/file.md:9
msgid "To open a file, create a File object with the filename as the argument"
msgstr ""

#: src/reference/nested/file.md:12 src/reference/nested/file.md:18
#: src/reference/nested/file.md:24
msgid "\"myfile.txt\""
msgstr ""

#: src/reference/nested/file.md:15
msgid ""
"which opens `\"myfile.txt\"` for _reading_. To open a file for writing or "
"appending, you need to provide a mode selector"
msgstr ""

#: src/reference/nested/file.md:18
msgid "\"write\""
msgstr ""

#: src/reference/nested/file.md:24
msgid "\"append\""
msgstr ""

#: src/reference/nested/file.md:27
msgid ""
"Once the file is open, you can then read or write by calling appropriate "
"methods:"
msgstr ""

#: src/reference/nested/file.md:30
msgid "// reads the contents of the file into an array of lines.\n"
msgstr ""

#: src/reference/nested/file.md:31
msgid "// reads a single line\n"
msgstr ""

#: src/reference/nested/file.md:32
msgid "// reads a single character.\n"
msgstr ""

#: src/reference/nested/file.md:33
msgid "// writes the arguments to the file.\n"
msgstr ""

#: src/reference/nested/file.md:36
msgid "After you're done with the file, close it with"
msgstr ""

#: src/reference/nested/file.md:44
msgid "lines"
msgstr ""

#: src/reference/nested/file.md:47
msgid ""
"Returns the contents of a file as an array of strings; each element "
"corresponds to a single line."
msgstr ""

#: src/reference/nested/file.md:49
msgid "Read in the contents of a file and print line by line:"
msgstr ""

#: src/reference/nested/file.md:52 src/reference/nested/file.md:66
msgid "\"input.txt\""
msgstr ""

#: src/reference/nested/file.md:58
msgid "readline"
msgstr ""

#: src/reference/nested/file.md:61
msgid "Reads a single line from a file; returns the result as a string."
msgstr ""

#: src/reference/nested/file.md:63
msgid "Read in the contents of a file and print each line:"
msgstr ""

#: src/reference/nested/file.md:73
msgid "readchar"
msgstr ""

#: src/reference/nested/file.md:76
msgid "Reads a single character from a file; returns the result as a string."
msgstr ""

#: src/reference/nested/file.md:78
msgid "write"
msgstr ""

#: src/reference/nested/file.md:81
msgid "Writes to a file."
msgstr ""

#: src/reference/nested/file.md:83
msgid "Write the contents of a list to a file:"
msgstr ""

#: src/reference/nested/file.md:86
msgid "\"output.txt\""
msgstr ""

#: src/reference/nested/file.md:86
msgid "\"w\""
msgstr ""

#: src/reference/nested/file.md:87
msgid "\"${i}: ${k}\""
msgstr ""

#: src/reference/nested/file.md:91
msgid "close"
msgstr ""

#: src/reference/nested/file.md:94
msgid "Closes an open file."
msgstr ""

#: src/reference/nested/file.md:96
msgid "eof"
msgstr ""

#: src/reference/nested/file.md:99
msgid "Returns true if at the end of the file; false otherwise"
msgstr ""

#: src/reference/nested/file.md:101
msgid "Folder"
msgstr ""

#: src/reference/nested/file.md:104
msgid ""
"The `Folder` class enables you to find whether a filepath refers to a "
"folder, and find the contents of that folder."
msgstr ""

#: src/reference/nested/file.md:106
msgid "Find whether a path refers to a folder:"
msgstr ""

#: src/reference/nested/file.md:109 src/reference/nested/file.md:115
msgid "\"path/folder\""
msgstr ""

#: src/reference/nested/file.md:112
msgid "Get a list of a folder's contents: "
msgstr ""

#: src/reference/nested/json.md:9
msgid ""
"The `JSON` class provides import and export functionality for the JSON "
"(JavaScript Object Notation) interchange file format as defined by IETF RFC "
"7159. "
msgstr ""

#: src/reference/nested/json.md:11
msgid "To parse a string that contains JSON, use the `parse` method: "
msgstr ""

#: src/reference/nested/json.md:14
msgid "\"[1,2,3,4]\""
msgstr ""

#: src/reference/nested/json.md:15
msgid "// expect: [ 1, 2, 3, 4 ]\n"
msgstr ""

#: src/reference/nested/json.md:18
msgid "Elements in the JSON string are converted to equivalent morpho values."
msgstr ""

#: src/reference/nested/json.md:20
msgid "To convert basic data types to JSON, use the `tostring` method: "
msgstr ""

#: src/reference/nested/json.md:26
msgid ""
"The exporter supports `nil`, boolean values `true` and `false`, numbers, "
"`String`s as well as `List` and `Dictionary` objects that may contain any of "
"the supported types. "
msgstr ""

#: src/reference/modules.md:3
msgid ""
"This section provides the documentation for the various standard modules "
"shipped with Morpho."
msgstr ""

#: src/reference/nested/color.md:7
msgid ""
"The `color` module provides support for working with color. Colors are "
"represented in morpho by `Color` objects. The module predefines some colors "
"including `Red`, `Green`, `Blue`, `Black`, `White`."
msgstr ""

#: src/reference/nested/color.md:9
msgid "To use the module, use import as usual:"
msgstr ""

#: src/reference/nested/color.md:15
msgid "Create a Color object from an RGB pair:"
msgstr ""

#: src/reference/nested/color.md:18
msgid "// A 50% gray\n"
msgstr ""

#: src/reference/nested/color.md:21
msgid ""
"The `color` module also provides `ColorMap`s, which are give a sequence of "
"colors as a function of a parameter; these are useful for plotting the "
"values of a `Field` for example."
msgstr ""

#: src/reference/nested/color.md:25
msgid "RGB"
msgstr ""

#: src/reference/nested/color.md:28
msgid ""
"Gets the rgb components of a `Color` or `ColorMap` object as a list. Takes a "
"single argument in the range 0 to 1, although the result will only depend on "
"this argument if the object is a `ColorMap`."
msgstr ""

#: src/reference/nested/color.md:35
msgid "Red"
msgstr ""

#: src/reference/nested/color.md:37 src/reference/nested/color.md:41
#: src/reference/nested/color.md:45 src/reference/nested/color.md:49
#: src/reference/nested/color.md:53 src/reference/nested/color.md:57
#: src/reference/nested/color.md:61 src/reference/nested/color.md:65
#: src/reference/nested/color.md:69 src/reference/nested/color.md:73
#: src/reference/nested/color.md:77 src/reference/nested/color.md:81
msgid "Built in `Color` object for use with the `graphics` and `plot` modules."
msgstr ""

#: src/reference/nested/color.md:39
msgid "Green"
msgstr ""

#: src/reference/nested/color.md:43
msgid "Blue"
msgstr ""

#: src/reference/nested/color.md:47
msgid "White"
msgstr ""

#: src/reference/nested/color.md:51
msgid "Black"
msgstr ""

#: src/reference/nested/color.md:55
msgid "Cyan"
msgstr ""

#: src/reference/nested/color.md:59
msgid "Magenta"
msgstr ""

#: src/reference/nested/color.md:63
msgid "Yellow"
msgstr ""

#: src/reference/nested/color.md:67
msgid "Brown"
msgstr ""

#: src/reference/nested/color.md:71
msgid "Orange"
msgstr ""

#: src/reference/nested/color.md:75
msgid "Pink"
msgstr ""

#: src/reference/nested/color.md:79
msgid "Purple"
msgstr ""

#: src/reference/nested/color.md:83
msgid "Colormap"
msgstr ""

#: src/reference/nested/color.md:85
msgid ""
"The `color` module provides `ColorMap`s which are subclasses of `Color` that "
"map a single parameter in the range 0 to 1 onto a continuum of colors. "
"`Color`s and `Colormap`s have the same interface."
msgstr ""

#: src/reference/nested/color.md:87
msgid "Get the red, green or blue components of a color or colormap:"
msgstr ""

#: src/reference/nested/color.md:91
msgid "// argument can be in range 0 to 1\n"
msgstr ""

#: src/reference/nested/color.md:94
msgid "Get all three components as a list:"
msgstr ""

#: src/reference/nested/color.md:100
msgid "Create a grayscale:"
msgstr ""

#: src/reference/nested/color.md:103
msgid "// 20% gray\n"
msgstr ""

#: src/reference/nested/color.md:106
msgid ""
"Available ColorMaps: `GradientMap`,  `GrayMap`, `HueMap`, `ViridisMap`, "
"`MagmaMap`, `InfernoMap` and `PlasmaMap`."
msgstr ""

#: src/reference/nested/color.md:108
msgid "GradientMap"
msgstr ""

#: src/reference/nested/color.md:111
msgid ""
"`GradientMap` is a `Colormap` that displays a white-green-purple sequence."
msgstr ""

#: src/reference/nested/color.md:113
msgid "GrayMap"
msgstr ""

#: src/reference/nested/color.md:116
msgid "`GrayMap` is a `Colormap` that displays grayscales."
msgstr ""

#: src/reference/nested/color.md:118
msgid "HueMap"
msgstr ""

#: src/reference/nested/color.md:121
msgid ""
"`HueMap` is a `Colormap` that displays vivid colors. It is periodic on the "
"interval 0 to 1."
msgstr ""

#: src/reference/nested/color.md:123
msgid "ViridisMap"
msgstr ""

#: src/reference/nested/color.md:126
msgid ""
"`ViridisMap` is a `Colormap` that displays a purple-green-yellow sequence. "
"It is perceptually uniform and intended to be improve the accessibility of "
"visualizations for viewers with color vision deficiency."
msgstr ""

#: src/reference/nested/color.md:129
msgid "MagmaMap"
msgstr ""

#: src/reference/nested/color.md:132
msgid ""
"`MagmaMap` is a `Colormap` that displays a black-red-yellow sequence. It is "
"perceptually uniform and intended to be improve the accessibility of "
"visualizations for viewers with color vision deficiency."
msgstr ""

#: src/reference/nested/color.md:135
msgid "InfernoMap"
msgstr ""

#: src/reference/nested/color.md:138
msgid ""
"`InfernoMap` is a `Colormap` that displays a black-red-yellow sequence. It "
"is perceptually uniform and intended to be improve the accessibility of "
"visualizations for viewers with color vision deficiency."
msgstr ""

#: src/reference/nested/color.md:141
msgid "PlasmaMap"
msgstr ""

#: src/reference/nested/color.md:144
msgid ""
"`InfernoMap` is a `Colormap` that displays a blue-red-yellow sequence. It is "
"perceptually uniform and intended to be improve the accessibility of "
"visualizations for viewers with color vision deficiency."
msgstr ""

#: src/reference/nested/constants.md:7
msgid ""
"The constants module contains a number of useful mathematical constants. "
"Import it like any other module:"
msgstr ""

#: src/reference/nested/constants.md:13
msgid "Available constants:"
msgstr ""

#: src/reference/nested/constants.md:15
msgid "`E` the base of natural logarithms."
msgstr ""

#: src/reference/nested/constants.md:16
msgid "`Pi` ratio of the perimeter of a circle to its diameter."
msgstr ""

#: src/reference/nested/delaunay.md:7
msgid ""
"The `delaunay` module creates Delaunay triangulations from point clouds. It "
"is dimensionally independent, so generates tetrahedra in 3D and higher order "
"simplices beyond."
msgstr ""

#: src/reference/nested/delaunay.md:9 src/reference/nested/implicitmesh.md:9
#: src/reference/nested/kdtree.md:9 src/reference/nested/plot.md:9
msgid "To use the module, first import it:"
msgstr ""

#: src/reference/nested/delaunay.md:15
msgid "To create a Delaunary triangulation from a list of points:"
msgstr ""

#: src/reference/nested/delaunay.md:24
msgid ""
"The module also provides `DelaunayMesh` to directly create meshes from "
"Delaunay triangulations."
msgstr ""

#: src/reference/nested/delaunay.md:28
msgid "Triangulate"
msgstr ""

#: src/reference/nested/delaunay.md:31
msgid ""
"The `triangulate` method performs the delaunay triangulation. To use it, "
"first construct a `Delaunay` object with the point cloud of interest: "
msgstr ""

#: src/reference/nested/delaunay.md:37
msgid "Then call `triangulate`:"
msgstr ""

#: src/reference/nested/delaunay.md:43
msgid "This returns a list of triangles `[ [i, j, k], ... ]`."
msgstr ""

#: src/reference/nested/delaunay.md:45
msgid "Circumsphere"
msgstr ""

#: src/reference/nested/delaunay.md:48
msgid ""
"The `Circumsphere` class calculates the circumsphere of a set of points, i."
"e. a sphere such that all the points are on the surface of the sphere. It is "
"used internally by the `delaunay` module."
msgstr ""

#: src/reference/nested/delaunay.md:50
msgid ""
"Create a `Circumsphere` from a list of points and a triangle specified by "
"indices into that list:"
msgstr ""

#: src/reference/nested/delaunay.md:56
msgid "Test if an arbitrary point is inside the `Circumsphere` or not: "
msgstr ""

#: src/reference/nested/graphics.md:7
msgid ""
"The `graphics` module provides a number of classes to provide simple "
"visualization capabilities. To use it, you first need to import the module:"
msgstr ""

#: src/reference/nested/graphics.md:13
msgid ""
"The `Graphics` class acts as an abstract container for graphical "
"information; to actually launch the display see the `Show` class. You can "
"create an empty scene like this,"
msgstr ""

#: src/reference/nested/graphics.md:19
msgid "Additional elements can be added using the `display` method."
msgstr ""

#: src/reference/nested/graphics.md:25
msgid "Morpho provides the following fundamental Graphical element classes:"
msgstr ""

#: src/reference/nested/graphics.md:31
msgid ""
"You can also use functions like `Arrow`, `Tube` and `Cylinder` to create "
"these elements conveniently."
msgstr ""

#: src/reference/nested/graphics.md:33
msgid "To combine graphics objects, use the add operator:"
msgstr ""

#: src/reference/nested/graphics.md:36
msgid "// ...\n"
msgstr ""

#: src/reference/nested/graphics.md:43
msgid "Show"
msgstr ""

#: src/reference/nested/graphics.md:46
msgid ""
"`Show` is used to launch an interactive graphical display using the external "
"`morphoview` application. `Show` takes a `Graphics` object as an argument:"
msgstr ""

#: src/reference/nested/graphics.md:53
msgid "TriangleComplex"
msgstr ""

#: src/reference/nested/graphics.md:56
msgid ""
"A `TriangleComplex` is a graphical element that can be used as part of a "
"graphical display. It consists of a list of vertices and a connectivity "
"matrix that selects which vertices are used in each triangle."
msgstr ""

#: src/reference/nested/graphics.md:58
msgid "To create one, call the constructor with the following arguments:"
msgstr ""

#: src/reference/nested/graphics.md:64
msgid "`position` is a `Matrix` containing vertex positions as _columns_."
msgstr ""

#: src/reference/nested/graphics.md:65
msgid "`normals` is a `Matrix` with a normal for each vertex."
msgstr ""

#: src/reference/nested/graphics.md:66
msgid "`colors` is the color of the object."
msgstr ""

#: src/reference/nested/graphics.md:67
msgid ""
"`connectivity` is a `Sparse` matrix where each column represents a triangle "
"and rows correspond to vertices."
msgstr ""

#: src/reference/nested/graphics.md:69 src/reference/nested/graphics.md:91
#: src/reference/nested/graphics.md:121 src/reference/nested/graphics.md:152
#: src/reference/nested/graphics.md:183 src/reference/nested/graphics.md:214
msgid "You can also provide optional arguments:"
msgstr ""

#: src/reference/nested/graphics.md:71
msgid ""
"`transmit` sets the transparency of the object. This parameter is only used "
"by the povray module as of now. Default is 0."
msgstr ""

#: src/reference/nested/graphics.md:73
msgid ""
"`filter` sets the transparency of the object using a filter effect. This "
"parameter is only used by the povray module as of now. Default is 0. For the "
"difference between `transmit` and `filter`, checkout the  [POVRay "
"documentation](http://xahlee.info/3d/povray-glassy.html)."
msgstr ""

#: src/reference/nested/graphics.md:78
msgid "Add to a `Graphics` object using the `display` method."
msgstr ""

#: src/reference/nested/graphics.md:80
msgid "Arrow"
msgstr ""

#: src/reference/nested/graphics.md:83
msgid "The `Arrow` function creates an arrow. It takes two arguments:"
msgstr ""

#: src/reference/nested/graphics.md:89
msgid ""
"`start` and `end` are the two vertices. The arrow points `start` -> `end`."
msgstr ""

#: src/reference/nested/graphics.md:93
msgid "`aspectratio` controls the width of the arrow relative to its length"
msgstr ""

#: src/reference/nested/graphics.md:94
msgid ""
"`n` is an integer that controls the quality of the display. Higher `n` leads "
"to a rounder arrow."
msgstr ""

#: src/reference/nested/graphics.md:95
msgid ""
"`color` is the color of the arrow. This can be a list of RGB values or a "
"`Color` object"
msgstr ""

#: src/reference/nested/graphics.md:96
msgid ""
"`transmit` sets the transparency of the arrow. This parameter is only used "
"by the povray module as of now. Default is 0."
msgstr ""

#: src/reference/nested/graphics.md:98
msgid ""
"`filter` sets the transparency of the arrow using a filter effect. This "
"parameter is only used by the povray module as of now. Default is 0. For the "
"difference between `transmit` and `filter`, checkout the  [POVRay "
"documentation](http://xahlee.info/3d/povray-glassy.html)."
msgstr ""

#: src/reference/nested/graphics.md:102
msgid "Display an arrow:"
msgstr ""

#: src/reference/nested/graphics.md:110
msgid "Cylinder"
msgstr ""

#: src/reference/nested/graphics.md:113
msgid ""
"The `Cylinder` function creates a cylinder. It takes two required arguments:"
msgstr ""

#: src/reference/nested/graphics.md:119
msgid "`start` and `end` are the two vertices."
msgstr ""

#: src/reference/nested/graphics.md:123
msgid ""
"`aspectratio` controls the width of the cylinder relative to its length."
msgstr ""

#: src/reference/nested/graphics.md:124
msgid ""
"`n` is an integer that controls the quality of the display. Higher `n` leads "
"to a rounder cylinder."
msgstr ""

#: src/reference/nested/graphics.md:125
msgid ""
"`color` is the color of the cylinder. This can be a list of RGB values or a "
"`Color` object."
msgstr ""

#: src/reference/nested/graphics.md:126
msgid ""
"`transmit` sets the transparency of the cylinder. This parameter is only "
"used by the povray module as of now. Default is 0."
msgstr ""

#: src/reference/nested/graphics.md:128
msgid ""
"`filter` sets the transparency of the cylinder using a filter effect. This "
"parameter is only used by the povray module as of now. Default is 0. For the "
"difference between `transmit` and `filter`, checkout the  [POVRay "
"documentation](http://xahlee.info/3d/povray-glassy.html)."
msgstr ""

#: src/reference/nested/graphics.md:132
msgid "Display an cylinder:"
msgstr ""

#: src/reference/nested/graphics.md:140
msgid "Tube"
msgstr ""

#: src/reference/nested/graphics.md:143
msgid "The `Tube` function connects a sequence of points to form a tube."
msgstr ""

#: src/reference/nested/graphics.md:149
msgid ""
"`points` is a list of points; this can be a list of lists or a `Matrix` with "
"the positions as columns."
msgstr ""

#: src/reference/nested/graphics.md:150
msgid "`radius` is the radius of the tube."
msgstr ""

#: src/reference/nested/graphics.md:154
msgid ""
"`n` is an integer that controls the quality of the display. Higher `n` leads "
"to a rounder tube."
msgstr ""

#: src/reference/nested/graphics.md:155
msgid ""
"`color` is the color of the tube. This can be a list of RGB values or a "
"`Color` object."
msgstr ""

#: src/reference/nested/graphics.md:156
msgid ""
"`closed` is a `bool` that indicates whether the tube should be closed to "
"form a loop."
msgstr ""

#: src/reference/nested/graphics.md:157
msgid ""
"`transmit` sets the transparency of the tube. This parameter is only used by "
"the povray module as of now. Default is 0."
msgstr ""

#: src/reference/nested/graphics.md:159
msgid ""
"`filter` sets the transparency of the tube using a filter effect. This "
"parameter is only used by the povray module as of now. Default is 0. For the "
"difference between `transmit` and `filter`, checkout the  [POVRay "
"documentation](http://xahlee.info/3d/povray-glassy.html)."
msgstr ""

#: src/reference/nested/graphics.md:163
msgid "Draw a square:"
msgstr ""

#: src/reference/nested/graphics.md:171
msgid "Sphere"
msgstr ""

#: src/reference/nested/graphics.md:174
msgid "The `Sphere` function creates a sphere."
msgstr ""

#: src/reference/nested/graphics.md:180
msgid ""
"`center` is the position of the center of the sphere; this can be a list or "
"column `Matrix`."
msgstr ""

#: src/reference/nested/graphics.md:181
msgid "`radius` is the radius of the sphere"
msgstr ""

#: src/reference/nested/graphics.md:185
msgid ""
"`color` is the color of the sphere. This can be a list of RGB values or a "
"`Color` object."
msgstr ""

#: src/reference/nested/graphics.md:186
msgid ""
"`transmit` sets the transparency of the sphere. This parameter is only used "
"by the povray module as of now. Default is 0."
msgstr ""

#: src/reference/nested/graphics.md:188
msgid ""
"`filter` sets the transparency of the sphere using a filter effect. This "
"parameter is only used by the povray module as of now. Default is 0. For the "
"difference between `transmit` and `filter`, checkout the  [POVRay "
"documentation](http://xahlee.info/3d/povray-glassy.html)."
msgstr ""

#: src/reference/nested/graphics.md:192
msgid "Draw some randomly sized spheres:"
msgstr ""

#: src/reference/nested/graphics.md:202
msgid "Text"
msgstr ""

#: src/reference/nested/graphics.md:205
msgid "A `Text` object is used to display text. "
msgstr ""

#: src/reference/nested/graphics.md:211
msgid "`text` is the text to display as a string."
msgstr ""

#: src/reference/nested/graphics.md:212
msgid "`position` is the position at which to display the text. "
msgstr ""

#: src/reference/nested/graphics.md:216
msgid "`color` is the color of the text. This should be a `Color` object."
msgstr ""

#: src/reference/nested/graphics.md:217
msgid ""
"`dirn` is the direction along which the text is drawn. This should be a "
"`List` or a `Matrix`."
msgstr ""

#: src/reference/nested/graphics.md:218
msgid "`size` is the font size to use"
msgstr ""

#: src/reference/nested/graphics.md:219
msgid "`vertical` is the vertical direction for the text"
msgstr ""

#: src/reference/nested/graphics.md:220
msgid "`font` is the `Font` object to use."
msgstr ""

#: src/reference/nested/graphics.md:222
msgid "Draw several pieces of text around the y axis:"
msgstr ""

#: src/reference/nested/implicitmesh.md:4
msgid "ImplicitMesh"
msgstr ""

#: src/reference/nested/implicitmesh.md:7
msgid ""
"The `implicitmesh` module allows you to build meshes from implicit "
"functions. For example, the unit sphere could be specified using the "
"function `x^2+y^2+z^2-1 == 0`."
msgstr ""

#: src/reference/nested/implicitmesh.md:15
msgid ""
"To create a sphere, first create an ImplicitMeshBuilder object with the "
"implict function you'd like to use:"
msgstr ""

#: src/reference/nested/implicitmesh.md:21
msgid ""
"You can use an existing function (or method) as well as an anonymous "
"function as above."
msgstr ""

#: src/reference/nested/implicitmesh.md:23
msgid "Then build the mesh,"
msgstr ""

#: src/reference/nested/implicitmesh.md:29
msgid "The `build` method takes a number of optional arguments:"
msgstr ""

#: src/reference/nested/implicitmesh.md:31
msgid ""
"`start` - the starting point. If not provided, the value Matrix(\\[1,1,1\\]) "
"is used."
msgstr ""

#: src/reference/nested/implicitmesh.md:32
msgid "`stepsize` - approximate lengthscale to use."
msgstr ""

#: src/reference/nested/implicitmesh.md:33
msgid ""
"`maxiterations` - maximum number of iterations to use. If this limit is "
"exceeded, a partially built mesh will be returned."
msgstr ""

#: src/reference/nested/kdtree.md:7
msgid ""
"The `kdtree` module implements a k-dimensional tree, a space partitioning "
"data structure that can be used to accelerate computational geometry "
"calculations."
msgstr ""

#: src/reference/nested/kdtree.md:15
msgid "To create a tree from a list of points:"
msgstr ""

#: src/reference/nested/kdtree.md:23
msgid "Add further points:"
msgstr ""

#: src/reference/nested/kdtree.md:29
msgid "Test whether a given point is present in the tree:"
msgstr ""

#: src/reference/nested/kdtree.md:35
msgid "Find all points within a given bounding box:"
msgstr ""

#: src/reference/nested/kdtree.md:42
msgid "Find the nearest point to a given point:"
msgstr ""

#: src/reference/nested/kdtree.md:54
msgid "Inserts a new point into a k-d tree. Returns a KDTreeNode object."
msgstr ""

#: src/reference/nested/kdtree.md:60
msgid ""
"Note that, for performance reasons, if the set of points is known ahead of "
"time, it is generally better to build the tree using the constructor "
"function KDTree rather than one-by-one with insert."
msgstr ""

#: src/reference/nested/kdtree.md:62
msgid "Ismember"
msgstr ""

#: src/reference/nested/kdtree.md:65
msgid "Checks if a point is a member of a k-d tree. Returns `true` or `false`."
msgstr ""

#: src/reference/nested/kdtree.md:71
msgid "Nearest"
msgstr ""

#: src/reference/nested/kdtree.md:74
msgid ""
"Finds the point in a k-d tree nearest to a point of interest. Returns a "
"KDTreeNode object."
msgstr ""

#: src/reference/nested/kdtree.md:80
msgid ""
"To get the location of this nearest point, access the location property:"
msgstr ""

#: src/reference/nested/kdtree.md:86
msgid "Search"
msgstr ""

#: src/reference/nested/kdtree.md:89
msgid ""
"Finds all points in a k-d tree that lie within a cuboidal bounding box. "
"Returns a list of KDTreeNode objects."
msgstr ""

#: src/reference/nested/kdtree.md:91
msgid ""
"Find and display all points that lie in a cuboid 0\\<=x\\<=1, 0\\<=y\\<=2, "
"1\\<=z\\<=2:"
msgstr ""

#: src/reference/nested/kdtree.md:98
msgid "KDTreeNode"
msgstr ""

#: src/reference/nested/kdtree.md:101
msgid ""
"An object corresponding to a single node in a k-d tree. To get the location "
"of the node, access the `location` property:"
msgstr ""

#: src/reference/nested/meshgen.md:7
msgid ""
"The `meshgen` module is used to create `Mesh` objects corresponding to a "
"specified domain. It provides the `MeshGen` class to perform the meshing, "
"which are created with the following arguments:"
msgstr ""

#: src/reference/nested/meshgen.md:13
msgid ""
"Domains are specified by a scalar function that is positive in the region to "
"be meshed and locally smooth. For example, to mesh the unit disk:"
msgstr ""

#: src/reference/nested/meshgen.md:19
msgid ""
"A `MeshGen` object is then created and then used to build the `Mesh` like "
"this:"
msgstr ""

#: src/reference/nested/meshgen.md:26
msgid ""
"A bounding box for the mesh must be specified as a `List` of `Range` "
"objects, one for each dimension. The increment on each `Range` gives an "
"approximate scale for the size of elements generated."
msgstr ""

#: src/reference/nested/meshgen.md:28
msgid ""
"To facilitate convenient creation of domains, a `Domain` class is provided "
"that provides set operations `union`, `intersection` and `difference`."
msgstr ""

#: src/reference/nested/meshgen.md:30
msgid "`MeshGen` accepts a number of optional arguments:"
msgstr ""

#: src/reference/nested/meshgen.md:32
msgid "`weight` A scalar weight function that controls mesh density."
msgstr ""

#: src/reference/nested/meshgen.md:33
msgid "`quiet` Set to `true` to suppress  `MeshGen` output."
msgstr ""

#: src/reference/nested/meshgen.md:34
msgid "`method` a list of options that controls the method used."
msgstr ""

#: src/reference/nested/meshgen.md:36
msgid "Some method choices that are available include:"
msgstr ""

#: src/reference/nested/meshgen.md:38
msgid "`\"FixedStepSize\"` Use a fixed step size in optimization."
msgstr ""

#: src/reference/nested/meshgen.md:39
msgid "`\"StartGrid\"` Start from a regular grid of points (the default)."
msgstr ""

#: src/reference/nested/meshgen.md:40
msgid "`\"StartRandom\"` Start from a randomly generated collection of points."
msgstr ""

#: src/reference/nested/meshgen.md:42
msgid ""
"There are also a number of properties of a `MeshGen` object that can be set "
"prior to calling `build` to control the operation of the mesh generation:"
msgstr ""

#: src/reference/nested/meshgen.md:44
msgid "`stepsize`, `steplimit` Stepsize used internally by the `Optimizer`"
msgstr ""

#: src/reference/nested/meshgen.md:45
msgid "`fscale` an internal \"pressure\""
msgstr ""

#: src/reference/nested/meshgen.md:46
msgid "`ttol` how far the vertices are allowed to move before retriangulation"
msgstr ""

#: src/reference/nested/meshgen.md:47
msgid "`etol` energy tolerance for optimization problem"
msgstr ""

#: src/reference/nested/meshgen.md:48
msgid ""
"`maxiterations` Maximum number of iterations of minimization + "
"retriangulation (default is 100)"
msgstr ""

#: src/reference/nested/meshgen.md:51
msgid "`MeshGen` picks default values that cover a reasonable range of uses."
msgstr ""

#: src/reference/nested/meshgen.md:55
msgid "Domain"
msgstr ""

#: src/reference/nested/meshgen.md:58
msgid ""
"The `Domain` class is used to conveniently build a domain by composing "
"simpler elements. "
msgstr ""

#: src/reference/nested/meshgen.md:60
msgid ""
"Create a `Domain` from a scalar function that is positive in the region of "
"interest:"
msgstr ""

#: src/reference/nested/meshgen.md:66
msgid "You can pass it to `MeshGen` to specify the region to mesh: "
msgstr ""

#: src/reference/nested/meshgen.md:72
msgid ""
"You can combine `Domain` objects using set operations `union`, "
"`intersection` and `difference`: "
msgstr ""

#: src/reference/nested/meshgen.md:81
msgid "CircularDomain"
msgstr ""

#: src/reference/nested/meshgen.md:84
msgid ""
"Conveniently constructs a `Domain` object correspondiong to a disk. Requires "
"the position of the center and a radius as arguments. "
msgstr ""

#: src/reference/nested/meshgen.md:86
msgid "Create a domain corresponding to the unit disk: "
msgstr ""

#: src/reference/nested/meshgen.md:92
msgid "RectangularDomain"
msgstr ""

#: src/reference/nested/meshgen.md:95
msgid ""
"Conveniently constructs a `Domain` object corresponding to a rectangle. "
"Requires a list of ranges as arguments. Works in arbitrary dimensions"
msgstr ""

#: src/reference/nested/meshgen.md:97
msgid "Create a square `Domain`:"
msgstr ""

#: src/reference/nested/meshgen.md:103
msgid "HalfSpaceDomain"
msgstr ""

#: src/reference/nested/meshgen.md:106
msgid ""
"Conveniently constructs a `Domain` object correspondiong to a half space "
"defined by a plane at `x0` and a normal `n`:"
msgstr ""

#: src/reference/nested/meshgen.md:112
msgid ""
"Note `n` is an \"outward\" normal, so points into the _excluded_ region."
msgstr ""

#: src/reference/nested/meshgen.md:114
msgid "Half space corresponding to the allowed region `x<0`:"
msgstr ""

#: src/reference/nested/meshgen.md:120
msgid ""
"Note that `HalfSpaceDomain`s cannot be meshed directly as they correspond to "
"an infinite region. They are useful, however, for combining with other "
"domains."
msgstr ""

#: src/reference/nested/meshgen.md:122
msgid ""
"Create half a disk by cutting a `HalfSpaceDomain` from a `CircularDomain`:"
msgstr ""

#: src/reference/nested/meshgen.md:132
msgid "MshGnDim"
msgstr ""

#: src/reference/nested/meshgen.md:135
msgid ""
"The `MeshGen` module currently supports 2 and 3 dimensional meshes. Higher "
"dimensional meshing will be available in a future release; please contact "
"the developer if you are interested in this functionality."
msgstr ""

#: src/reference/nested/meshslice.md:7
msgid ""
"The `meshslice` module is used to slice a `Mesh` object along a given plane, "
"yielding a new `Mesh` object of lower dimensionality. You can also use "
"`meshslice` to project `Field` objects onto the new mesh."
msgstr ""

#: src/reference/nested/meshslice.md:9
msgid "To use the module, begin by importing it:"
msgstr ""

#: src/reference/nested/meshslice.md:15
msgid ""
"Then construct a `MeshSlicer` object, passing the mesh you want to slice in "
"the constructor:"
msgstr ""

#: src/reference/nested/meshslice.md:21
msgid ""
"You then perform a slice by calling the `slice` method, passing the plane "
"you want to slice through. This method returns a new `Mesh` object "
"comprising the slice. A plane is defined by a point that lies on the plane "
"`pt` and a direction normal to the plan `dirn`:"
msgstr ""

#: src/reference/nested/meshslice.md:27
msgid ""
"Having performed a slice, you can then project any associated `Field` "
"objects onto the sliced mesh by calling the `slicefield` method:"
msgstr ""

#: src/reference/nested/meshslice.md:34
msgid ""
"The new field returned by `slicefield` lives on the sliced mesh. You can "
"slice any number of fields."
msgstr ""

#: src/reference/nested/meshslice.md:36
msgid ""
"You can perform multiple slices with the same `MeshSlicer` simply by calling "
"`slice` again with a different plane."
msgstr ""

#: src/reference/nested/meshslice.md:38
msgid "SlcEmpty"
msgstr ""

#: src/reference/nested/meshslice.md:41
msgid ""
"This error occurs if you try to use `slicefield` on a `MeshSlicer` without "
"having performed a slice. For example:"
msgstr ""

#: src/reference/nested/meshslice.md:45
msgid "// Throws SlcEmpty\n"
msgstr ""

#: src/reference/nested/meshslice.md:49
msgid "To fix, call `slice` before `slicefield`:"
msgstr ""

#: src/reference/nested/meshslice.md:54
msgid "// Now slices correctly \n"
msgstr ""

#: src/reference/nested/meshtools.md:7
msgid ""
"The Meshtools package contains a number of functions and classes to assist "
"with creating and manipulating meshes."
msgstr ""

#: src/reference/nested/meshtools.md:14
msgid ""
"This function creates a mesh composed of triangles from a parametric "
"function. To use it:"
msgstr ""

#: src/reference/nested/meshtools.md:22 src/reference/nested/meshtools.md:66
msgid ""
"`function` is a parametric function that has one parameter. It should return "
"a list of coordinates or a column matrix corresponding to this parameter."
msgstr ""

#: src/reference/nested/meshtools.md:23
msgid ""
"`range1` is the Range to use for the first parameter of the parametric "
"function."
msgstr ""

#: src/reference/nested/meshtools.md:24
msgid ""
"`range2` is the Range to use for the second parameter of the parametric "
"function."
msgstr ""

#: src/reference/nested/meshtools.md:25
msgid ""
"`closed` is an optional parameter indicating whether to create a closed loop "
"or not. You can supply a list where each element indicates whether the "
"relevant parameter is closed or not."
msgstr ""

#: src/reference/nested/meshtools.md:27
msgid "To use `AreaMesh`, import the `meshtools` module:"
msgstr ""

#: src/reference/nested/meshtools.md:33
msgid "Create a square:"
msgstr ""

#: src/reference/nested/meshtools.md:39
msgid "Create a tube:"
msgstr ""

#: src/reference/nested/meshtools.md:46
msgid "Create a torus:"
msgstr ""

#: src/reference/nested/meshtools.md:58
msgid ""
"This function creates a mesh composed of line elements from a parametric "
"function. To use it:"
msgstr ""

#: src/reference/nested/meshtools.md:67
msgid "`range` is the Range to use for the parametric function."
msgstr ""

#: src/reference/nested/meshtools.md:68
msgid ""
"`closed` is an optional parameter indicating whether to create a closed loop "
"or not."
msgstr ""

#: src/reference/nested/meshtools.md:70
msgid "To use `LineMesh`, import the `meshtools` module:"
msgstr ""

#: src/reference/nested/meshtools.md:76
msgid "Create a circle:"
msgstr ""

#: src/reference/nested/meshtools.md:86
msgid "This function creates a mesh corresponding to a polyhedron. "
msgstr ""

#: src/reference/nested/meshtools.md:92
msgid ""
"where `vertices` is a list of vertices and `faces` is a list of faces "
"specified as a list of vertex indices."
msgstr ""

#: src/reference/nested/meshtools.md:94
msgid "To use `PolyhedronMesh`, import the `meshtools` module:"
msgstr ""

#: src/reference/nested/meshtools.md:100
msgid "Create a cube:"
msgstr ""

#: src/reference/nested/meshtools.md:111
msgid ""
"_Note_ that the vertices in each face list must be specified strictly in "
"cyclic order."
msgstr ""

#: src/reference/nested/meshtools.md:116
msgid ""
"The `DelaunayMesh` constructor function creates a `Mesh` object directly "
"from a point cloud using the Delaunay triangulator."
msgstr ""

#: src/reference/nested/meshtools.md:125
msgid ""
"You can control the output dimension of the mesh (e.g. to create a 2D mesh "
"embedded in 3D space) using the optional `outputdim` property. "
msgstr ""

#: src/reference/nested/meshtools.md:131
msgid "Equiangulate"
msgstr ""

#: src/reference/nested/meshtools.md:134
msgid ""
"Attempts to equiangulate a mesh, exchanging elements to improve their "
"regularity."
msgstr ""

#: src/reference/nested/meshtools.md:140
msgid "This function takes optional arguments:"
msgstr ""

#: src/reference/nested/meshtools.md:142
msgid "`quiet`: Set to true to silence messages."
msgstr ""

#: src/reference/nested/meshtools.md:143
msgid ""
"`fix`: Supply a `Selection` containing edges that should not be modified by "
"equiangulation."
msgstr ""

#: src/reference/nested/meshtools.md:145
msgid ""
"_Note_ this function modifies the mesh in place; it does not create a new "
"mesh."
msgstr ""

#: src/reference/nested/meshtools.md:150
msgid ""
"Changes the dimension in which a mesh is embedded. For example, you may have "
"created a mesh in 2D that you now wish to use in 3D."
msgstr ""

#: src/reference/nested/meshtools.md:152
msgid "To use:"
msgstr ""

#: src/reference/nested/meshtools.md:158
msgid ""
"where `mesh` is the mesh you wish to change, and `dim` is the new embedding "
"dimension."
msgstr ""

#: src/reference/nested/meshtools.md:163
msgid ""
"The `MeshBuilder` class simplifies user creation of meshes. To use this "
"class, begin by creating a `MeshBuilder` object:"
msgstr ""

#: src/reference/nested/meshtools.md:169
msgid ""
"You can then add vertices, edges, etc. one by one using `addvertex`, "
"`addedge`, `addface` and `addelement`. Each of these returns an element id:"
msgstr ""

#: src/reference/nested/meshtools.md:177
msgid ""
"Once the mesh is ready, call the `build` method to construct the `Mesh`:"
msgstr ""

#: src/reference/nested/meshtools.md:183
msgid ""
"You can specify the dimension of the `Mesh` explicitly when initializing the "
"`MeshBuilder`: "
msgstr ""

#: src/reference/nested/meshtools.md:189
msgid "or implicitly when adding the first vertex:"
msgstr ""

#: src/reference/nested/meshtools.md:193
msgid "// A 2D mesh\n"
msgstr ""

#: src/reference/nested/meshtools.md:196
msgid "MshBldDimIncnstnt"
msgstr ""

#: src/reference/nested/meshtools.md:199
msgid ""
"This error is produced if you try to add a vertex that is inconsistent with "
"the mesh dimension, e.g."
msgstr ""

#: src/reference/nested/meshtools.md:203
msgid "// Throws an error! \n"
msgstr ""

#: src/reference/nested/meshtools.md:206
msgid "To fix this ensure all vertices have the correct dimension."
msgstr ""

#: src/reference/nested/meshtools.md:208
msgid "MshBldDimUnknwn"
msgstr ""

#: src/reference/nested/meshtools.md:211
msgid ""
"This error is produced if you try to add an element to a `MeshBuilder` "
"object but haven't yet specified the dimension (at initialization) or by "
"adding a vertex."
msgstr ""

#: src/reference/nested/meshtools.md:215
msgid "// No vertices have been added \n"
msgstr ""

#: src/reference/nested/meshtools.md:218
msgid "To fix this add the vertices first."
msgstr ""

#: src/reference/nested/meshtools.md:220
msgid "MeshRefiner"
msgstr ""

#: src/reference/nested/meshtools.md:223
msgid ""
"The `MeshRefiner` class is used to refine meshes, and to correct associated "
"data structures that depend on the mesh."
msgstr ""

#: src/reference/nested/meshtools.md:225
msgid ""
"To prepare for refining, first create a `MeshRefiner` object either with a "
"`Mesh`,"
msgstr ""

#: src/reference/nested/meshtools.md:231 src/reference/nested/meshtools.md:266
msgid ""
"or with a list of objects that can include a `Mesh` as well as `Field`s and "
"`Selection`s."
msgstr ""

#: src/reference/nested/meshtools.md:237
msgid ""
"To perform the refinement, call the `refine` method. You can refine all "
"elements,"
msgstr ""

#: src/reference/nested/meshtools.md:243
msgid "or refine selected elements using a `Selection`,"
msgstr ""

#: src/reference/nested/meshtools.md:249
msgid ""
"The `refine` method returns a `Dictionary` that maps old objects to new, "
"refined objects. Use this to update your data structures."
msgstr ""

#: src/reference/nested/meshtools.md:255
msgid "MeshPruner"
msgstr ""

#: src/reference/nested/meshtools.md:258
msgid ""
"The `MeshPruner` class is used to prune excessive detail from meshes (a "
"process that's sometimes referred to as coarsening), and to correct "
"associated data structures that depend on the mesh."
msgstr ""

#: src/reference/nested/meshtools.md:260
msgid "First create a `MeshPruner` object either with a `Mesh`,"
msgstr ""

#: src/reference/nested/meshtools.md:272
msgid "To perform the coarsening, call the `prune` method with a `Selection`,"
msgstr ""

#: src/reference/nested/meshtools.md:278
msgid ""
"The `prune` method returns a `Dictionary` that maps old objects to new, "
"refined objects. Use this to update your data structures."
msgstr ""

#: src/reference/nested/meshtools.md:284
msgid "MeshMerge"
msgstr ""

#: src/reference/nested/meshtools.md:288
msgid ""
"The `MeshMerge` class is used to combine meshes into a single mesh, removing "
"any duplicate elements."
msgstr ""

#: src/reference/nested/meshtools.md:290
msgid "To use, create a `MeshMerge` object with a list of meshes to merge,"
msgstr ""

#: src/reference/nested/meshtools.md:296
msgid "and then call the `merge` method to return a combined mesh:"
msgstr ""

#: src/reference/nested/optimize.md:7
msgid ""
"The `optimize` package contains a number of functions and classes to perform "
"shape optimization."
msgstr ""

#: src/reference/nested/optimize.md:11
msgid "OptimizationProblem"
msgstr ""

#: src/reference/nested/optimize.md:14
msgid ""
"An `OptimizationProblem` object defines an optimization problem, which may "
"include functionals to optimize as well as global and local constraints."
msgstr ""

#: src/reference/nested/optimize.md:16
msgid "Create an `OptimizationProblem` with a mesh:"
msgstr ""

#: src/reference/nested/optimize.md:22
msgid "Add an energy:"
msgstr ""

#: src/reference/nested/optimize.md:29
msgid ""
"Add an energy that operates on a selected region, and with an optional "
"prefactor:"
msgstr ""

#: src/reference/nested/optimize.md:35
msgid "Add a constraint:"
msgstr ""

#: src/reference/nested/optimize.md:41
msgid "Add a local constraint (here a onesided level set constraint):"
msgstr ""

#: src/reference/nested/optimize.md:48
msgid "Optimizer"
msgstr ""

#: src/reference/nested/optimize.md:51
msgid ""
"`Optimizer` objects are used to optimize `Mesh`es and `Field`s. You should "
"use the appropriate subclass: `ShapeOptimizer` or `FieldOptimizer` "
"respectively."
msgstr ""

#: src/reference/nested/optimize.md:55
msgid "ShapeOptimizer"
msgstr ""

#: src/reference/nested/optimize.md:58
msgid ""
"A `ShapeOptimizer` object performs shape optimization: it moves the vertex "
"positions to reduce an overall energy."
msgstr ""

#: src/reference/nested/optimize.md:60
msgid ""
"Create a `ShapeOptimizer` object with an `OptimizationProblem` and a `Mesh`:"
msgstr ""

#: src/reference/nested/optimize.md:66
msgid "Take a step down the gradient with fixed stepsize:"
msgstr ""

#: src/reference/nested/optimize.md:69
msgid "// Takes five steps\n"
msgstr ""

#: src/reference/nested/optimize.md:72
msgid "Linesearch down the gradient:"
msgstr ""

#: src/reference/nested/optimize.md:75
msgid "// Performs five linesearches\n"
msgstr ""

#: src/reference/nested/optimize.md:78
msgid "Perform conjugate gradient (usually gives faster convergence):"
msgstr ""

#: src/reference/nested/optimize.md:81
msgid "// Performs five conjugate gradient steps.\n"
msgstr ""

#: src/reference/nested/optimize.md:84
msgid "Control a number of properties of the optimizer:"
msgstr ""

#: src/reference/nested/optimize.md:87
msgid "// The stepsize to take\n"
msgstr ""

#: src/reference/nested/optimize.md:88
msgid "// Maximum stepsize for optimizing methods\n"
msgstr ""

#: src/reference/nested/optimize.md:89
msgid "// Energy convergence tolerance\n"
msgstr ""

#: src/reference/nested/optimize.md:90
msgid "// Tolerance to which constraints are satisfied\n"
msgstr ""

#: src/reference/nested/optimize.md:91
msgid "// Maximum number of constraint steps to use\n"
msgstr ""

#: src/reference/nested/optimize.md:94
msgid "FieldOptimizer"
msgstr ""

#: src/reference/nested/optimize.md:97
msgid ""
"A `FieldOptimizer` object performs field optimization: it changes elements "
"of a `Field` to reduce an overall energy."
msgstr ""

#: src/reference/nested/optimize.md:99
msgid ""
"Create a `FieldOptimizer` object with an `OptimizationProblem` and a `Field`:"
msgstr ""

#: src/reference/nested/optimize.md:105
msgid ""
"Field optimizers provide the same options and methods as Shape optimizers: "
"see the `ShapeOptimizer` documentation for details."
msgstr ""

#: src/reference/nested/plot.md:7
msgid ""
"The `plot` module provides visualization capabilities for Meshes, Selections "
"and Fields. These functions produce Graphics objects that can be displayed "
"with `Show`."
msgstr ""

#: src/reference/nested/plot.md:17
msgid "Plotmesh"
msgstr ""

#: src/reference/nested/plot.md:20
msgid "Visualizes a `Mesh` object:"
msgstr ""

#: src/reference/nested/plot.md:26
msgid ""
"Plotmesh accepts a number of optional arguments to control what is displayed:"
msgstr ""

#: src/reference/nested/plot.md:28
msgid "`selection` - Only elements in a provided `Selection` are drawn."
msgstr ""

#: src/reference/nested/plot.md:29 src/reference/nested/plot.md:44
#: src/reference/nested/plot.md:63
msgid ""
"`grade` - Only draw the specified grade. This can also be a list of multiple "
"grades to draw."
msgstr ""

#: src/reference/nested/plot.md:30
msgid "`color` - Draw the mesh in a provided `Color`."
msgstr ""

#: src/reference/nested/plot.md:31 src/reference/nested/plot.md:64
#: src/reference/nested/plot.md:81
msgid ""
"`filter` and `transmit` - Used by the `povray` module to indicate "
"transparency."
msgstr ""

#: src/reference/nested/plot.md:33
msgid "Plotmeshlabels"
msgstr ""

#: src/reference/nested/plot.md:36
msgid "Draws the ids for elements in a `Mesh`: "
msgstr ""

#: src/reference/nested/plot.md:42
msgid ""
"Plotmeshlabels accepts a number of optional arguments to control the output: "
msgstr ""

#: src/reference/nested/plot.md:45
msgid "`selection` - Only labels in a provided `Selection` are drawn."
msgstr ""

#: src/reference/nested/plot.md:46
msgid ""
"`offset` - Local offset vector for labels. Can be a `List`, a `Matrix` or a "
"function. "
msgstr ""

#: src/reference/nested/plot.md:47
msgid ""
"`dirn` - Text direction for labels. Can be a `List`, a `Matrix` or a "
"function. "
msgstr ""

#: src/reference/nested/plot.md:48
msgid ""
"`vertical` - Text vertical direction. Can be a `List`, a `Matrix` or a "
"function. "
msgstr ""

#: src/reference/nested/plot.md:49
msgid ""
"`color` - Label color. Can be a `Color` object or a `Dictionary` of colors "
"for each grade. "
msgstr ""

#: src/reference/nested/plot.md:50
msgid "`fontsize` - Font size to use. "
msgstr ""

#: src/reference/nested/plot.md:52
msgid "Plotselection"
msgstr ""

#: src/reference/nested/plot.md:55
msgid "Visualizes a `Selection` object:"
msgstr ""

#: src/reference/nested/plot.md:61
msgid ""
"Plotselection accepts a number of optional arguments to control what is "
"displayed:"
msgstr ""

#: src/reference/nested/plot.md:66
msgid "Plotfield"
msgstr ""

#: src/reference/nested/plot.md:69
msgid "Visualizes a scalar `Field` object:"
msgstr ""

#: src/reference/nested/plot.md:75
msgid ""
"Plotfield accepts a number of optional arguments to control what is "
"displayed:"
msgstr ""

#: src/reference/nested/plot.md:77
msgid "`grade` - Draw the specified grade."
msgstr ""

#: src/reference/nested/plot.md:78
msgid ""
"`colormap` - A `Colormap` object to use. The field is automatically scaled."
msgstr ""

#: src/reference/nested/plot.md:79
msgid "`scalebar` - A `Scalebar` object to use. "
msgstr ""

#: src/reference/nested/plot.md:80
msgid "`style` - Plot style. See below. "
msgstr ""

#: src/reference/nested/plot.md:82
msgid ""
"`cmin` and `cmax` - Can be used to define the data range covered. Values "
"beyond these limits will be colored by the lower/upper bound of the colormap "
"accordingly."
msgstr ""

#: src/reference/nested/plot.md:86
msgid "Supported plot styles: "
msgstr ""

#: src/reference/nested/plot.md:88
msgid ""
"`default` - Color `Mesh` elements by the corresponding value of the `Field`."
msgstr ""

#: src/reference/nested/plot.md:89
msgid "`interpolate` - Interpolate `Field` quantities onto higher elements."
msgstr ""

#: src/reference/nested/plot.md:91
msgid "ScaleBar"
msgstr ""

#: src/reference/nested/plot.md:94
msgid "Represents a scalebar for a plot: "
msgstr ""

#: src/reference/nested/plot.md:100
msgid "`ScaleBar`s can be created with many adjustable parameters: "
msgstr ""

#: src/reference/nested/plot.md:102
msgid "`nticks` - Maximum number of ticks to show."
msgstr ""

#: src/reference/nested/plot.md:103
msgid "`posn` - Position to draw the `ScaleBar`. "
msgstr ""

#: src/reference/nested/plot.md:104
msgid "`length` - Length of `ScaleBar` to draw. "
msgstr ""

#: src/reference/nested/plot.md:105
msgid "`dirn` - Direction to draw the `ScaleBar` in. "
msgstr ""

#: src/reference/nested/plot.md:106
msgid "`tickdirn` - Direction to draw the ticks in. "
msgstr ""

#: src/reference/nested/plot.md:107
msgid "`colormap` - `ColorMap` to use."
msgstr ""

#: src/reference/nested/plot.md:108
msgid "`textdirn` - Direction to draw labels in. "
msgstr ""

#: src/reference/nested/plot.md:109
msgid "`textvertical` - Label vertical direction. "
msgstr ""

#: src/reference/nested/plot.md:110
msgid "`fontsize` - Fontsize for labels"
msgstr ""

#: src/reference/nested/plot.md:111
msgid "`textcolor` - Color for labels "
msgstr ""

#: src/reference/nested/plot.md:113
msgid "You can draw the `ScaleBar` directly by calling the `draw` method: "
msgstr ""

#: src/reference/nested/plot.md:119
msgid ""
"where `min` and `max` are the minimum and maximum values to display on the "
"scalebar. "
msgstr ""

#: src/reference/nested/povray.md:7
msgid ""
"The `povray` module provides integration with POVRay, a popular open source "
"ray-tracing package for high quality graphical rendering. To use the module, "
"first import it:"
msgstr ""

#: src/reference/nested/povray.md:13
msgid "To raytrace a graphic, begin by creating a `POVRaytracer` object:"
msgstr ""

#: src/reference/nested/povray.md:19
msgid "Create a .pov file that can be run with POVRay:"
msgstr ""

#: src/reference/nested/povray.md:22 src/reference/nested/povray.md:28
msgid "\"out.pov\""
msgstr ""

#: src/reference/nested/povray.md:25
msgid "Create, render and display a scene using POVRay:"
msgstr ""

#: src/reference/nested/povray.md:31
msgid "This also creates the .png file for the scene."
msgstr ""

#: src/reference/nested/povray.md:33
msgid "The `POVRaytracer` constructor supports an optional `camera` argument:"
msgstr ""

#: src/reference/nested/povray.md:35
msgid ""
"`camera` - a `Camera` object (see below / help) containing the settings for "
"the povray camera."
msgstr ""

#: src/reference/nested/povray.md:38 src/reference/nested/povray.md:75
msgid "The `Camera` object can be initialized as follows:"
msgstr ""

#: src/reference/nested/povray.md:44 src/reference/nested/povray.md:81
msgid ""
"This object contains the default settings of the camera, which can be "
"changed using the following optional arguments, or by just setting the "
"attributes after instantiation:"
msgstr ""

#: src/reference/nested/povray.md:48 src/reference/nested/povray.md:85
msgid ""
"`antialias` - whether to antialias the output or not (`true` by default)"
msgstr ""

#: src/reference/nested/povray.md:49 src/reference/nested/povray.md:86
msgid "`width` - image width (`2048` by default)"
msgstr ""

#: src/reference/nested/povray.md:50 src/reference/nested/povray.md:87
msgid "`height` - image height (`1536` by default)"
msgstr ""

#: src/reference/nested/povray.md:51 src/reference/nested/povray.md:88
msgid "`viewangle` - camera angle (higher means wider view) (`24` by default)"
msgstr ""

#: src/reference/nested/povray.md:52 src/reference/nested/povray.md:89
msgid "`viewpoint` - position of camera (`Matrix([0,0,-5])` by default)"
msgstr ""

#: src/reference/nested/povray.md:53 src/reference/nested/povray.md:90
msgid "`look_at` - coordinate to look at (`Matrix([0,0,0])` by defualt)"
msgstr ""

#: src/reference/nested/povray.md:54 src/reference/nested/povray.md:91
msgid "`sky` - orientation pointing to the sky (`Matrix([0,1,0])` by default)"
msgstr ""

#: src/reference/nested/povray.md:56 src/reference/nested/povray.md:97
msgid ""
"The default settings generate a reasonable centered view of the x-y plane."
msgstr ""

#: src/reference/nested/povray.md:59
msgid ""
"These attributes can also be set directly for the `POVRaytracer` object:"
msgstr ""

#: src/reference/nested/povray.md:65
msgid "The `render` method supports a few optional boolean arguments:"
msgstr ""

#: src/reference/nested/povray.md:67
msgid ""
"`quiet` - whether to suppress the parser and render statistics from `povray` "
"or not (`false` by default)"
msgstr ""

#: src/reference/nested/povray.md:68
msgid ""
"`display` - whether to turn on the graphic display while rendering or not "
"(`true` by default) "
msgstr ""

#: src/reference/nested/povray.md:69
msgid ""
"`shadowless` - whether to turn off the shadows while rendering (`false` by "
"default)"
msgstr ""

#: src/reference/nested/povray.md:70
msgid ""
"`transparent` - whether to render the graphic with a transparent background "
"in the output PNG (`false` by default)"
msgstr ""

#: src/reference/nested/povray.md:72
msgid "Camera"
msgstr ""

#: src/reference/nested/vtk.md:7
msgid ""
"The vtk module contains classes to allow I/O of meshes and fields using the "
"VTK Legacy Format. Note that this currently only supports scalar or 2D/3D "
"vector (column matrix) fields that live on the vertices ( shape `[1,0,0]`). "
"Support for tensorial fields and fields on cells coming soon."
msgstr ""

#: src/reference/nested/vtk.md:13
msgid "VTKExporter"
msgstr ""

#: src/reference/nested/vtk.md:16
msgid ""
"This class can be used to export the field(s) and/or a mesh at a given state "
"to a single .vtk file. To use it, import the `vtk` module:"
msgstr ""

#: src/reference/nested/vtk.md:23
msgid "Initialize the `VTKExporter`"
msgstr ""

#: src/reference/nested/vtk.md:29
msgid "where `obj` can either be"
msgstr ""

#: src/reference/nested/vtk.md:31
msgid "A `Mesh` object: This prepares the Mesh for exporting."
msgstr ""

#: src/reference/nested/vtk.md:32
msgid ""
"A `Field` object: This prepares both the Field and the Mesh associated with "
"it for exporting."
msgstr ""

#: src/reference/nested/vtk.md:35
msgid "Use the `export` method to export to a VTK file. "
msgstr ""

#: src/reference/nested/vtk.md:38 src/reference/nested/vtk.md:110
msgid "\"output.vtk\""
msgstr ""

#: src/reference/nested/vtk.md:41
msgid ""
"Optionally, use the `addfield` method to add one or more fields before "
"exporting:"
msgstr ""

#: src/reference/nested/vtk.md:45 src/reference/nested/vtk.md:86
#: src/reference/nested/vtk.md:157
msgid "\"f\""
msgstr ""

#: src/reference/nested/vtk.md:48
msgid "where,"
msgstr ""

#: src/reference/nested/vtk.md:50
msgid "`f` is the field object to be exported"
msgstr ""

#: src/reference/nested/vtk.md:51
msgid ""
"`fieldname` is an optional argument that assigns a name to the field in the "
"VTK file. This name is required to be a character string without embedded "
"whitespace. If not provided, the name would be either \"scalars\" or "
"\"vectors\" depending on the field type\\*\\*. "
msgstr ""

#: src/reference/nested/vtk.md:56
msgid ""
"\\** Note that this currently only supports scalar or 2D/3D vector (column "
"matrix) fields that live on the vertices ( shape `[1,0,0]`). Support for "
"tensorial fields and fields on cells coming soon."
msgstr ""

#: src/reference/nested/vtk.md:60 src/reference/nested/vtk.md:141
msgid "Minimal example:"
msgstr ""

#: src/reference/nested/vtk.md:72
msgid "// Export just the mesh \n"
msgstr ""

#: src/reference/nested/vtk.md:74
msgid "\"mesh.vtk\""
msgstr ""

#: src/reference/nested/vtk.md:86
msgid "// Export fields\n"
msgstr ""

#: src/reference/nested/vtk.md:90 src/reference/nested/vtk.md:161
msgid "\"g\""
msgstr ""

#: src/reference/nested/vtk.md:94 src/reference/nested/vtk.md:149
msgid "\"data.vtk\""
msgstr ""

#: src/reference/nested/vtk.md:97
msgid "VTKImporter"
msgstr ""

#: src/reference/nested/vtk.md:100
msgid ""
"This class can be used to import the field(s) and/or the  mesh at a given "
"state from a single .vtk file. To use it, import the `vtk` module:"
msgstr ""

#: src/reference/nested/vtk.md:107
msgid "Initialize the `VTKImporter` with the filename"
msgstr ""

#: src/reference/nested/vtk.md:113
msgid "Use the `mesh` method to get the mesh:"
msgstr ""

#: src/reference/nested/vtk.md:119
msgid "Use the `field` method to get the field:"
msgstr ""

#: src/reference/nested/vtk.md:125
msgid ""
"Use the `fieldlist` method to get the list of the names of the fields "
"contained in the file:"
msgstr ""

#: src/reference/nested/vtk.md:131
msgid ""
"Use the `containsfield` method to check whether the file contains a field by "
"a given `fieldname`:"
msgstr ""

#: src/reference/nested/vtk.md:139
msgid "where `fieldname` is the name assigned to the field in the .vtk file"
msgstr ""

#: src/mdbook_notes.md:3
msgid ""
"This is a conversion of the [Morpho](https://github.com/Morpho-lang/morpho) "
"manual from the original [LyX/TeX](https://github.com/Morpho-lang/morpho-"
"manual) to an `mdBook` format."
msgstr ""

#: src/mdbook_notes.md:5
msgid ""
"_Morpho_ is designed by Prof. Timothy J. Atherton at Tufts University. This "
"conversion is my hobby-work done during my time at Tufts as a postdoctoral "
"scholar with him."
msgstr ""

#: src/mdbook_notes.md:7
msgid ""
"Here are my few design goals for this conversion. Some are already met, some "
"are a work in progress:"
msgstr ""

#: src/mdbook_notes.md:8
msgid "Faithfully reproduce all the content of the manual (done)"
msgstr ""

#: src/mdbook_notes.md:9
msgid "Emphasize accessibility, especially of the math content (wip)"
msgstr ""

#: src/mdbook_notes.md:10
msgid ""
"Ensure easy extension in the future by streamlining the automation. (some "
"portions are very much not streamlined right now!)"
msgstr ""

#: src/mdbook_notes.md:12
msgid ""
"I found `mdBook` very easy to use and was able to set-up the basic website "
"without any use of HTML/CSS. I am open to suggestions to move this to "
"another tool."
msgstr ""

#: src/mdbook_notes.md:14
msgid ""
"To build the book, you need to have [`mdbook`](https://github.com/rust-lang/"
"mdBook) installed. You can install it with `cargo`:"
msgstr ""

#: src/mdbook_notes.md:20
msgid ""
"Then, you need to generate the figures and the reference section by running "
"the `build.py` script:"
msgstr ""

#: src/mdbook_notes.md:24
msgid ""
"(Make sure to change the `libmorphofolder` path to your local libmorpho "
"folder in the `build.py` script. In the future, we will auto-download the "
"help from GitHub.)"
msgstr ""

#: src/mdbook_notes.md:26
msgid "Finally, you can build the book by running `mdbook`:"
msgstr ""

#: src/mdbook_notes.md:31
msgid ""
"This will generate the HTML files in the `book` directory. You can view the "
"book by opening the `index.html` file in your browser."
msgstr ""

#: src/mdbook_notes.md:33
msgid "To preview the book, you can run the following command:"
msgstr ""

#: src/mdbook_notes.md:38
msgid "Authoring Guidelines"
msgstr ""

#: src/mdbook_notes.md:40
msgid ""
"The general guidelines for writing a book with `mdBook` can be found in "
"their [user guide](https://rust-lang.github.io/mdBook/index.html)."
msgstr ""

#: src/mdbook_notes.md:42
msgid "Equations are handled using slightly modified MathJax:"
msgstr ""

#: src/mdbook_notes.md:43
msgid ""
"Inline equations are delimited by `\\\\(` and `\\\\)` (same as `mdBook` "
"default)."
msgstr ""

#: src/mdbook_notes.md:44
msgid "Block equations are delimited by `$$` and `$$`."
msgstr ""

#: src/mdbook_notes.md:45
msgid ""
"Auto-numbering and cross-referencing support is limited, numbering not "
"including chapter and section numbers, and cross-referencing limited to "
"within a single `.md` file."
msgstr ""

#: src/mdbook_notes.md:46
msgid "Labeling an equation is same as in TeX:"
msgstr ""

#: src/mdbook_notes.md:55
msgid "Cross-referencing within the document can be done by `\\eqref`:"
msgstr ""

#: src/mdbook_notes.md:59
msgid "See the [Electrostatics example](examples/electrostatics.md) for usage."
msgstr ""

#: src/mdbook_notes.md:61
msgid "Morpho code is syntax-highlighted using the JavaScript syntax for now:"
msgstr ""

#: src/mdbook_notes.md:68
msgid "renders to"
msgstr ""

#: src/mdbook_notes.md:72
msgid "Generating the MarkDown files from the original manual"
msgstr ""

#: src/mdbook_notes.md:74
msgid ""
"This mdBook was generated by a series of conversions of the [original LyX "
"file](https://github.com/Morpho-lang/morpho/blob/main/manual/src/manual.lyx)."
msgstr ""

#: src/mdbook_notes.md:76
msgid "Export the LyX file as a `.tex` file"
msgstr ""

#: src/mdbook_notes.md:77
msgid ""
"Convert it to markdown with MathJax using Pandoc using the following command:"
msgstr ""

#: src/mdbook_notes.md:82
msgid ""
"Replace `$...$` with `\\\\(...\\\\)` within this MarkDown file to make the "
"inline math compatible with MathJax (I used a small `re` script available on "
"the GitHub repository under `src/replacedollars.py`)."
msgstr ""

#: src/mdbook_notes.md:84
msgid "Contributing"
msgstr ""

#: src/mdbook_notes.md:86
msgid ""
"Contributions are absolutely welcome! Check out the [Issues](https://github."
"com/joshichaitanya3/morpho-manual/issues) on GitHub or make a pull request!"
msgstr ""
